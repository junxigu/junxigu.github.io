<!DOCTYPE html>
<html>

  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>面向对象系统的基本知识</title>

	<link rel="stylesheet" href="/styles/css/index.css">
	<link rel="stylesheet" href="/styles/css/fontawesome/css/font-awesome.min.css">
	<link rel="canonical" href="/2016/10/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/">
	<link rel="alternate" type="application/rss+xml" title="Jun Xi Gu 的博客" href="/feed.xml">
	
	<meta name="description" content="顾俊喜;个人博客">

	<script src="/styles/js/jquery.min.js"></script>
	<!--[if lt IE 9]>
    	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  	<![endif]-->
  	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?94be4b0f9fc5d94cc0d0415ea6761ae9";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
  	<style type="text/css">
	  	.docs-content{
	  		margin-bottom: 10px;
	  	}
  	</style>
</head>

  <body class="index">

    <header class="navbar navbar-inverse navbar-fixed-top docs-nav" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">    
        <li>
          <a href="/">主页</a>
        </li>
        <li>
          <a href="/categories/">分类博客</a>
        </li>
        <li>
          <a href="/tag">标签博客</a>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">关于<b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li><a rel="nofollow" target="_blank" href="https://github.com/junxigu/">Github</a></li>
            <li><a rel="nofollow" target="_blank" href="https://github.com/luoyan35714/LessOrMore.git">本博客模板</a></li>
          </ul>
        </li>
      </ul>
    </nav>
  </div>
</header>
    <div class="docs-header" id="content">
  <div class="container">
  	
  		<!--
		    <h1>面向对象系统的基本知识</h1>
		    <p>Post on Oct 20, 2016 by <a href="/about">Jun Xi Gu</a></p>
		-->
		    <h1>Stay Hungry Stay Foolish</h1>
    
  </div>
</div>
    
      
<div class="banner">
  <div class="container">
  	
    	<a href="/categories/#技术-ref">技术</a>	/
    	<a href="/tag/#OO-ref">OO</a>
    
  </div>
</div>

    

    <div class="container docs-container">
  <div class="row">
    <div class="col-md-3">
      <div class="sidebar hidden-print" role="complementary">
        <div id="navigation">
  <h1>目录</h1>
  <ul class="nav sidenav">
<!--
    
      
      
      
      

      
        <li><a href="#year_2017">2017</a>
          <ul class="nav">
            <li><a href="#month_2017_January">January</a></li>
      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
        
            </ul>
          </li>
          <li><a href="#year_2016">2016</a>
            <ul class="nav">
              <li><a href="#month_2016_December">December</a></li>
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2016_November">November</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2016_October">October</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2016_September">September</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            </ul>
          </li>
      
    
-->
  </ul>
</div> 
      </div>
    </div>
    <div class="col-md-9" role="main">
      <div class="panel docs-content">
        <div class="wrapper">
            <header class="post-header">
              <h1 class="post-title">面向对象系统的基本知识</h1>
              <!--
                <p class="post-meta">Oct 20, 2016</p>
              -->
              <div class="meta">Posted on <span class="postdate">Oct 20, 2016</span> By <a target="_blank" href="">Jun Xi Gu</a></div>
              <br />
            </header>
            <article class="post-content">
              <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">面向对象的基本术语</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">面向对象系统的核心概念</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">代码和功能的复用机制</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">面向对象设计的原则</a></li>
</ul>

<p><strong>本文是对面向对象系统的基本知识的汇总和个人理解</strong></p>

<hr />

<h2 id="section">面向对象的基本术语</h2>

<p><strong>方法</strong> 是一个操作或一个请求，包含名字，参数和返回值</p>

<p><strong>接口</strong> 是一系列方法的集合，对象可以拥有接口，所以接口体现了一个对象所能完成的功能</p>

<p><strong>类型</strong> 是一个接口的名字，可以理解为等同于接口，类型可以有子类型和父类性，当一个类型包含另一个类型的时即为子类型</p>

<p><strong>类</strong> 定义一个对象，提供（多个）类型里方法的实现，这是对象的一个静态写照</p>

<p><strong>对象</strong> 面向对象系统里运行时的基本元素，通过各个对象之间的交互（互相发送请求消息）来实现面向系统的功能;对象之间可以相互交互，对象是一个类的实例化，可以拥有多个类型</p>

<p>例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>interfaced Duck { // 类型
	void quark() // 方法
}

class ConcreteDuck implements Duck { // 类，定义了Duck类型的实现
	static void quark() {
		// real quark
	}
	
	public static void main(String[] args) {1l
		Duck d1 = new ConcreteDuck();
		Duck d2 = new ConcreteDuck();
		
		d1.quark();
		d1.quark();
	}
}
</code></pre>
</div>

<p><img src="../../../../styles/images/runtime.png" alt="runtime" /></p>

<h2 id="section-1">面向对象系统的核心概念</h2>

<p><strong>封装</strong> 把数据和对数据的操作聚合起来形成一个对象</p>

<p>例如:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Duck { // 把name和quark封装成一个对象
	String name;
	
	void quark() {
		System.out.println(name + " quarking...");
	}
}
</code></pre>
</div>

<p><strong>继承</strong> 包括两个含义</p>

<ul>
  <li>类型继承：定义子类型，实现不同类型的替换</li>
  <li>实现继承：实现代码的复用和实现的方法重定义</li>
</ul>

<p>类型继承举例:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>interface Quarkable {
	void quark()
}

interface Duck extends { // 类型继承
}

class ConcreteQuarkable implements Quarkable {}

class ConcreteDucke implements Quarkable {}

class Demo {
	static void runDemo(Quarkable q) {
		q.quark()
	}
	
	public static void main(String[] args) {1l
		runDemo(new ConcreteQuarkable());
		runDemo(new ConcreteDucke());
	}
}
</code></pre>
</div>

<p>实现继承举例:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class ConcreteQuarkable {
	void quark() { }
}

class ConcreteDucke1 extends ConcreteQuarkable { } // 继承了quark的实现

class ConcreteDucke2 extends ConcreteQuarkable {
	void quark() { }  // 重定义了quark的实现
}
</code></pre>
</div>

<p><strong>多态</strong> 在运行时动态的替换拥有相同类型的对象，如上类型继承举例</p>

<h2 id="section-2">代码和功能的复用机制</h2>

<p><strong>继承</strong> 可以实现代码的复用，缺点：这是在编译时实现的代码复用，所以是一种相对运行时来说的静态复用，不够灵活;子类会破坏父类的封装性，并对父类的代码产生依赖；优点是简单粗暴</p>

<p>举例：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class HashSet {
	...
	void addAll(Collection c) {
		for(Object o : i)
			add(o);
	}
	
	void add(Object o) {
		...
	}
	...
}

class BraokenSubSet { // broken cause dependency
	int counter = 0;

	@Override void add(Object o) { couter++; super.add(o); }
	
	@Override void addAll(Collection c) { couter += c.size(); super.addAll(c); }
}
</code></pre>
</div>

<p><strong>组合</strong> 可以实现运行时的对象功能复用，通过多态能更加灵活; 缺点是会增加对象的数量导致增加运行时的复杂性</p>

<p>举例：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>interfaced Duck {
	void quark()
}

class Demo {
	Duck d；
	
	Demo(Duck d) { this.d = d; }
	
	void setDuck(Duck d) { this.d = d; }
	
	void quark() { d.quark(); }
	
	public static void main(String[] args) {
		Demo demo = new Demo(new Duck(){
			void quark() {
				// implement version 1
			}
		});
		demo.quark();
		
		demo.setDuck((new Duck(){
			void quark() {
				// implement version 2
			}
		});
		demo.quark();
	}
}
</code></pre>
</div>

<p><strong>委托</strong> 通过组合来复用代码的功能，但又不需要继承</p>

<p>例如:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>interface Duck { void quark(); }

class ConcreteDucke1 extends Duck { 
	void quark() { }
}

class ConcreteDucke2 extends ConcreteQuarkable {
	ConcreteDucke1 d;
	
	ConcreteDucke2(ConcreteDucke1 d) { this.d = d; }
	
	void quark() { d.quark(); }
}
</code></pre>
</div>

<p><strong>参数化类型</strong> 把类型作为一种可变的参数，是的代码不依赖于类型</p>

<p>例如：List，Set，Map等</p>

<h2 id="section-3">面向对象设计的原则</h2>

<p>前提：视情况有取舍地使用这些原则，没有死规定</p>

<p><strong>封装变化</strong> 把可变的部分封装成对象</p>

<p>例如：父类的两方法的实现在子类中存在着变化和重复时，应该单独封装</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// Bad example
class Duck {
	void fly() { System.out.println("Fly"); }
	void quark() { System.out.println("quark"); }
}

class ToyDuck extends Duck {
	@Override void fly() {}
	@Override void quark() { System.out.println("toy quark"); }
}

class WildDuck extends Duck {
	@Override void fly() { System.out.println("Fly Height"); }
	@Override void quark() { System.out.println("quark loudly"); }
}

class CannotFlyWildDuck extends Duck {
	@Override void fly() {} // 重复的代码
	@Override void quark() { System.out.println("quark loudly"); } // 重复的代码
}

// Good Example
interface Quarkable { void quark(); }

class Normal implements Quarkable { void quark() { System.out.println("quark"); } }
class Silece implements Quarkable { void quark() {} }
class Loud implements Quarkable { void quark() { System.out.println("quark loudly"); } }
class ToySound implements Quarkable { void quark() { System.out.println("toy quark"); } }

abstract Duck {
	Quarkable q;
	Duck() { this.q = new Normal(); }
	void quark() { q.quark(); }
	
	void fly();
}

class Duck extends Duck {
	void fly() { System.out.println("Fly"); }
}

class CannotFlyWildDuck extends Duck {
	@Override void fly() {}
}

class ToyDuck extends CannotFlyWildDuck {
	ToyDuck() { this.q = new ToySound(); }
}

class WildDuck extends Duck {
	WildDuck() { this.q = new Loud(); }
	@Override void fly() { System.out.println("Fly Height"); }
}
</code></pre>
</div>

<p><strong>针对接口编程而非针对实现编程</strong> 包括2个方面：</p>

<ul>
  <li>客户代码使用接口编程能获得动态替换具体实现的灵活性</li>
  <li>接口的实现部分可以获得独立性和扩展性</li>
</ul>

<p><strong>多用组合，少用继承</strong> 对父类实现的依赖导致父类的修改影响到子类</p>

<p><strong>为了交互对象之间的松耦合设计而努力</strong> 松耦合是指交互的对象之间不知道彼此的实现细节，只知道彼此拥有的接口，所以对象的具体实现的改变能互不影响</p>

<p><strong>开放–关闭原则</strong> 已有代码应该对扩展开放，对修改关闭；集中精力实现最后可能改变的地方即可</p>

<p><strong>依赖倒置原则</strong> 要依赖抽象的类型，不要依赖具体实现的类；编码时就是高层组件不要依赖底层组件</p>

<p><strong>最少只是原则</strong> 尽量减少对象间的相互依赖，否则动一发而动全身；要遵守这个原则就应该之访问以下范围内的对象的方法：</p>

<ul>
  <li>该对象本身</li>
  <li>作为参数传进来的对象</li>
  <li>此方法所创建的对象</li>
  <li>对象的组件</li>
</ul>

<p><strong>好莱坞原则：别调用我们，我们调用你</strong> 高层组件决定怎样使用提供给底层组件的钩子</p>

<p><strong>单一责任原则</strong> 一个类应该只有一个引起变化的原因</p>


            </article>
        </div>
      </div>
      <div class="panel docs-content">
        <article class="post-content">
          <div class="wrapper">
            


  <div class="ds-thread" data-thread-key="/2016/10/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" data-title="面向对象系统的基本知识" data-url="/2016/10/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"></div>

<script type="text/javascript">
var duoshuoQuery = {short_name:"junxigu"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
</script>


 
          </div>
        </article>
      </div>
    </div>
  </div>
</div>

    
    <footer class="footer" role="contentinfo">
	<div class="container">
		<p class="copyright">Copyright &copy; 2014-2017 <a href=""><code>Jun Xi Gu</code></a>.</p>
		<p>Customizied from <a href="https://github.com/luoyan35714/LessOrMore">LessOrMore</a></p></p>
		<p>Powered by <a href="http://jekyllrb.com">Jekyll</a>, theme from <a href="http://lesscss.cn/">Less</a></p>
	</div>
</footer>

<script src="/styles/js/jquery.min.js"></script>
<script src="/styles/js/bootstrap.min.js"></script>
<script src="/styles/js/holder.min.js"></script>
<script src="/styles/js/application.js"></script>
<script src="/styles/js/lessismore.js"></script>

  </body>
</html>
