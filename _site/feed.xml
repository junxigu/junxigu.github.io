<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>个人技术博客</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 30 Nov 2016 15:22:38 +0800</pubDate>
    <lastBuildDate>Wed, 30 Nov 2016 15:22:38 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Java 类型的生命周期</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;装载&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;验证&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;准备&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;解析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;初始化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;卸载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java 类型的生命周期的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt; Java的类型以class文件的形式被导入到JVM中，然后被程序使用，当不再使用时被JVM卸载&lt;/p&gt;

&lt;p&gt;JVM规范没有规定什么时候导入class文件，但规定了JVM在 主动使用 一个类型之前必须已经完成class的导入；导入包括装载，链接和初始化 3个阶段；&lt;/p&gt;

&lt;p&gt;以下场景属于对一个类型的主动使用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建一个类的实例&lt;/li&gt;
  &lt;li&gt;调用类的静态方法&lt;/li&gt;
  &lt;li&gt;使用类或接口的静态变量(非编译常量)&lt;/li&gt;
  &lt;li&gt;使用Java API的某些反射方法&lt;/li&gt;
  &lt;li&gt;初始化一个类的子类&lt;/li&gt;
  &lt;li&gt;当虚拟机启动某个被标明为启动类的类&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;子类或子接口通过继承得来的静态变量只是被动使用&lt;/p&gt;

&lt;p&gt;class的装载，链接和初始化 必须按照顺序进行，但链接中的 部分对class的验证过程会在装载中执行，链接中的解析可以延迟到初始化之后进行&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;装载&lt;/h3&gt;

&lt;p&gt;装载阶段需要完成3项任务&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过类型的全限定名产生一个class格式的二进制流&lt;/li&gt;
  &lt;li&gt;解析二进制流并生成方法区内的内部数据结构&lt;/li&gt;
  &lt;li&gt;创建该类型的Class实例&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;验证&lt;/h3&gt;

&lt;p&gt;对class格式的二进制流的验证部分发生在装载期间(如检查class的文件格式，长度)，部分发生在解析期间(验证符号引用)，除此以外，验证阶段验证的内容包括各类二进制兼容性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;检查final类不能拥有子类&lt;/li&gt;
  &lt;li&gt;检查final方法不能被覆盖&lt;/li&gt;
  &lt;li&gt;确保在类型和超类之间不存在不兼容的方法声明&lt;/li&gt;
  &lt;li&gt;检查所有常量池入口相互一致&lt;/li&gt;
  &lt;li&gt;检查常量池中所有的特殊字符串&lt;/li&gt;
  &lt;li&gt;检查字节码的完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;准备&lt;/h3&gt;

&lt;p&gt;JVM为类变量分配内存并初始化为默认值&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;解析&lt;/h3&gt;

&lt;p&gt;对常量池中的符号引用替换为直接引用&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;初始化&lt;/h3&gt;

&lt;p&gt;若父类未初始化受限初始化父类，然后执行类的静态初始化语句来初始化类变量的值&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;卸载&lt;/h3&gt;

&lt;p&gt;当一个类型的Class对象在垃圾收集时没有办法被 触及 就可以触发垃圾回收(具体的回收策略由JVM的具体实现决定)，当一个类的对象能被触及，则垃圾回收器则通过该对象找到方法区中的类型信息，通过方法区中的Class对象引用 触及它&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Nov 2016 10:00:00 +0800</pubDate>
        <link>/2016/11/30/DEEP_IN_JAVA_VM_Java_class_lifecycle/</link>
        <guid isPermaLink="true">/2016/11/30/DEEP_IN_JAVA_VM_Java_class_lifecycle/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java的网路移动性</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;Java的网路移动性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java的网路移动性的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;java&quot;&gt;Java的网路移动性&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java平台通过其内部机制支持在不同的主机JVM中交换 程序和数据&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务商通过网路给客户机分发服务，而服务是 可执行程序和数据的集合，Java平台能的实现这种需求&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么样？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java的平台无关性和安全性是其网络移动性的基础，还通过 动态链接，class文件的紧凑性、JAR文件 来减少程序的传送时间&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Nov 2016 10:00:00 +0800</pubDate>
        <link>/2016/11/30/DEEP_IN_JAVA_VM_Java_NEMO/</link>
        <guid isPermaLink="true">/2016/11/30/DEEP_IN_JAVA_VM_Java_NEMO/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java 代码签名和认证</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java--&quot; id=&quot;markdown-toc-java--&quot;&gt;Java对 公私钥和证书 的支持&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java---1&quot; id=&quot;markdown-toc-java---1&quot;&gt;Java对 使用私钥签名对代码 的支持&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java 代码签名和认证的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Java对代码进行数字签名和认证需要使用公私钥和证书，对数字签名的原理不熟悉可先阅读这篇简单易懂的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html&quot; title=&quot;数字签名是什么?&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;java--&quot;&gt;Java对 公私钥和证书 的支持&lt;/h3&gt;

&lt;p&gt;Java提供了内置的工具 keytool 给用户创建 公私钥和证书，用户创建的公私钥和证书是储存在一个 keystore 文件中，keystore文件中可以储存多对公私钥和证书，每对公私钥和证书会与一个 别名 相关联，用户使用 别名 来从keystore文件里获取公私钥和证书&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/java_sign_0.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个创建公私钥和证书的例子&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 把class文件打包到一个jar文件里
jar cvf example.jar *.class

// 用keytool生成一对公私钥和证书，这些公私钥和证书储存在example_key_store文件，别名是example_alias，获
// 取这对公私钥所用的密码是example_key_pass；创建过程需要填入一些信息，如果example_key_store本来不存在则
// keytool会创建一个并需要你输入example_key_store的密码(可忽略,假设使用密码example_key_store_pass)
keytool -genkey -alias example_alias -keypass example_key_pass -validity 10000 -keystore example_key_store

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;java---1&quot;&gt;Java对 使用私钥签名对代码 的支持&lt;/h3&gt;

&lt;p&gt;Java能对jar包进行签名，所以需要把class文件放到jar包里，并且能对签名后的jar包进行认证&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/java_sign_1.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/java_sign_2.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个签名的例子&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 用jarsigner对example.jar认证，需要使用别名example_alias从example_key_store里使用密码
// example_key_pass获取私钥
jarsigner -keystore example_key_store -storepass example_key_store_pass -keypass example_key_pass example.jar example_alias

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 23 Nov 2016 10:00:00 +0800</pubDate>
        <link>/2016/11/23/DEEP_IN_JAVA_VM__java_signature_and_authentication/</link>
        <guid isPermaLink="true">/2016/11/23/DEEP_IN_JAVA_VM__java_signature_and_authentication/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java的安全性</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java-&quot; id=&quot;markdown-toc-java-&quot;&gt;Java 安全性是什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java--1&quot; id=&quot;markdown-toc-java--1&quot;&gt;Java 为什么需要安全性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java--2&quot; id=&quot;markdown-toc-java--2&quot;&gt;Java 怎么样实现安全性&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;类加载器体系结构&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#class&quot; id=&quot;markdown-toc-class&quot;&gt;class文件检验器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;Java虚拟机中内置的安全特性&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#java-api&quot; id=&quot;markdown-toc-java-api&quot;&gt;安全管理器和Java API&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java的安全性的汇总和个人理解，此处的内容是针对旧版的Java&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;java-&quot;&gt;Java 安全性是什么&lt;/h2&gt;

&lt;p&gt;Java 通过其安全模型 来保护终端用户免受从网路下载的、来自不可靠来源的、恶意程序的侵犯&lt;/p&gt;

&lt;h2 id=&quot;java--1&quot;&gt;Java 为什么需要安全性&lt;/h2&gt;

&lt;p&gt;Java 程序是可从任意来源获取并运行的，因此需要保证运行这些代码时能进行限制，免受恶意代码的破坏&lt;/p&gt;

&lt;h2 id=&quot;java--2&quot;&gt;Java 怎么样实现安全性&lt;/h2&gt;

&lt;p&gt;Java 使用沙箱模型来对程序运行进行限制，防止其进行破坏，沙箱模型由一些基本组件组成&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类加载器体系结构&lt;/li&gt;
  &lt;li&gt;class文件检验器&lt;/li&gt;
  &lt;li&gt;内置于Java虚拟机(及语言)的安全特性&lt;/li&gt;
  &lt;li&gt;安全管理器及Java API&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/Java安全体系.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前三个组成部分是为了保证JVM和它正在运行的应用程序的完整性，免受下载的恶意程序的侵犯；最后一个部分是为了保护外部资源不被JVM中运行的恶意程序侵犯&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;类加载器体系结构&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类加载器是用于动态的加载类二进制流的对象&lt;/li&gt;
  &lt;li&gt;类加载有4类：启动类加载器(java内部实现，负责加载java核心API)、标准扩展类加载器(java自带，加载ext目录下的类)、类路径类加载器(java自带，加载CLASS_PATH环境变量下的类)、自定义类加载器&lt;/li&gt;
  &lt;li&gt;类加载器使用双亲委派模式进行类的加载(非启动类加载器都有一个双亲类加载器的引用，加载类时会先让双亲加载，若双亲加载不到才自己加载)，启动类加载器 &amp;lt;- 标准扩展类加载器 &amp;lt;- 类路径类加载器 &amp;lt;- 自定义类加载器,保证可信的类由可信的类加载器优先加载&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;类加载器是可信和不可信程序的入口，通过类加载器体系机构能够在一定程度上实现可信程序和不可信程序的隔离，并能对不可信的程序的资源访问进行限制&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么样？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;类加载器体系结构的作用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;防止恶意代码干涉正常代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不同的类加载器加载的代码属于不同的命名空间(相同的类可以用不同类加载器多次加载到JVM)，不同的命名空间中的代码不能互相访问(除非显式运行交互)，达到隔离恶意代码的效果&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;守护了被信任的类库的边界&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用类加载器双亲委托模型来保证所有信任的类库都通过信任的加载器来加载，不可靠的类可以使用自定义的加载器加载&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为类创建保护域，由保护域来确定类所拥有的权限&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个类都属于一个保护域，用户可以为某个保护域的类设置资源的访问权限策略，这样就能起到限制代码权限的作用&lt;/p&gt;

&lt;h3 id=&quot;class&quot;&gt;class文件检验器&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;class文件检验器是对 类加载器加载的类 进行检查的对象&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;虚拟机不能保证 加载的类 是由合法的编译器生成的，需要对类二进制流的 结构，类型，语义，符号引用信息 进行检查，保证其完整性和健壮性&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么样？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;class文件检验器需要进行四趟扫描来完成校验&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;class文件的结构检查&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;检查class文件的结构是否满足java对于一个类型的结构的定义，包括魔数、结构、长度等&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类型数据的语义检查&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;检查各个组成部分的类型是否满足其所属的类型的定义，并检查这个类文件本身的类是否满足编译器所规定的条件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;字节码验证&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过对字节码流中的操作码，操作数进行检查，保证所有字节码都能安全的执行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;符号引用的验证&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在执行过程中第一次引用新的类型时需要进行动态链接，这时候需要对引用的合法性(存在性等)进行校验，从而保证被引用的类文件的二进制兼容性&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;Java虚拟机中内置的安全特性&lt;/h3&gt;

&lt;p&gt;JVM通过在执行过程中加入以下特性来增强程序的健壮性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类型安全的引用转换&lt;/li&gt;
  &lt;li&gt;结构化的内存访问&lt;/li&gt;
  &lt;li&gt;自动垃圾收集&lt;/li&gt;
  &lt;li&gt;数组边界检查&lt;/li&gt;
  &lt;li&gt;空引用检查&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java-api&quot;&gt;安全管理器和Java API&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安全访问器是一个对象，它能确定一个程序是否有权限访问一个受保护的资源&lt;/p&gt;

&lt;p&gt;所有对资源的访问都是通过Java API来完成的，当给应用程序赋予了一个安全管理器实例时，则Java API在访问资源前都会让安全管理器确认程序是否有权限访问资源&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过把对资源的访问封装在Java API里，然后API在访问资源前使用安全管理器确认程序是否有权限访问资源，这样就能保护外部资源不被不受信任的程序访问&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么样？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java通过签名对 受信任的代码 确定其身份和完整性&lt;/p&gt;

&lt;p&gt;一个class文件有它的代码来源，代码来源是指 代码从哪来、若被签名则是从谁那里来&lt;/p&gt;

&lt;p&gt;代码对资源所拥有的访问权限都与代码的代码来源相关联，所以在给某段代码赋予权限时，要制定其来源和所拥有权限&lt;/p&gt;

&lt;p&gt;所有的代码权限赋予都记录在一个ASCII策略文件里，文件里的内容有固定的语法，内容大意是 给 某个代码来源的代码 赋予 访问某种资源的权限&lt;/p&gt;

&lt;p&gt;类加载器 在加载类时 会给类创建一个保护域，保护域里有策略文件里定义的代码来源 和 所拥有的权限(类加载器也可以不参考策略文件)，当程序使用Java API时，安全管理器 能通过代码的保护域中的权限来确定代码是否能访问资源&lt;/p&gt;

</description>
        <pubDate>Tue, 22 Nov 2016 10:00:00 +0800</pubDate>
        <link>/2016/11/22/DEEP_IN_JAVA_VM__security/</link>
        <guid isPermaLink="true">/2016/11/22/DEEP_IN_JAVA_VM__security/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java平台的无关性</title>
        <description>
&lt;p&gt;&lt;strong&gt;本文是对Java平台无关性的汇总和个人理解，此处的内容是针对旧版的Java&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Java平台的不同版本体现其 平台无关性 和 伸缩性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不同版本间支持的API集合不同&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;J2EE：适合作为高端性能的服务器上的Java平台&lt;/li&gt;
  &lt;li&gt;J2SE：适合作为浏览器上或桌面应用上的Java平台&lt;/li&gt;
  &lt;li&gt;J2ME：适合作为资源高度受限的嵌入式设备上的Java平台&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;影响Java程序的平台无关性的一些因素&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所针对的硬件平台是否已经存在相应的Java平台实现&lt;/li&gt;
  &lt;li&gt;Java程序使用的API集合在网路中的不同节点的Java平台是否存在&lt;/li&gt;
  &lt;li&gt;Java平台的版本改变后对原有程序使用的API的影响&lt;/li&gt;
  &lt;li&gt;Java程序是否使用了本地方法&lt;/li&gt;
  &lt;li&gt;Java程序是否使用了某些硬件平台厂商提供的特定扩展库&lt;/li&gt;
  &lt;li&gt;Java程序是否依赖特定Java平台的实现(及时终结，线程的优先级)&lt;/li&gt;
  &lt;li&gt;对用户界面的依赖&lt;/li&gt;
  &lt;li&gt;Java平台中的bug&lt;/li&gt;
  &lt;li&gt;不同Java平台不同实现导致的功能，性能不一致&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;开发平台无关的Java程序的步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;选定要运行的主机和设备集合&lt;/li&gt;
  &lt;li&gt;选定一个足够好的Java平台&lt;/li&gt;
  &lt;li&gt;对每个目标主机和设备选定一个Java平台实现&lt;/li&gt;
  &lt;li&gt;编写程序时只使用标准的API&lt;/li&gt;
  &lt;li&gt;编写程序时不要依赖及时终结和线程优先级&lt;/li&gt;
  &lt;li&gt;努力设计一个能在每个平台正常运行的界面&lt;/li&gt;
  &lt;li&gt;在所有目标主机和设备上测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;是否选择平台无关需要考虑性能，功能等各种因素&lt;/p&gt;

</description>
        <pubDate>Tue, 08 Nov 2016 10:00:00 +0800</pubDate>
        <link>/2016/11/08/DEEP_IN_JAVA_VM__plateform_unrelated/</link>
        <guid isPermaLink="true">/2016/11/08/DEEP_IN_JAVA_VM__plateform_unrelated/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java平台系统的基本知识</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java4&quot; id=&quot;markdown-toc-java4&quot;&gt;Java平台系统中由4个独立并相关的技术构成&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java-&quot; id=&quot;markdown-toc-java-&quot;&gt;Java平台的目标 平台无关性，安全性和网路移动性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java4-1&quot; id=&quot;markdown-toc-java4-1&quot;&gt;Java平台通过4个技术的结合来实现其目标&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;Java的劣势&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java平台系统的基本知识的汇总和个人理解，此处的内容是针对旧版的Java&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;java4&quot;&gt;Java平台系统中由4个独立并相关的技术构成&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Java程序设计语言&lt;/li&gt;
  &lt;li&gt;Java Class文件&lt;/li&gt;
  &lt;li&gt;Java API(rt.jar等)，提供访问系统底层资源的统一接口&lt;/li&gt;
  &lt;li&gt;Java虚拟机&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/Java平台组成及关系.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;java-&quot;&gt;Java平台的目标 平台无关性，安全性和网路移动性&lt;/h2&gt;

&lt;p&gt;现代的硬件发展趋势和软件发展趋势 需要大型系统能实现 平台无关性，安全性和网路移动性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;平台无关性：程序一次开发可以在多种目标硬件平台都能使用、执行，不需要针对特定硬件平台做移植、定制&lt;/li&gt;
  &lt;li&gt;安全性：通过某种方式获得的程序的可校验，权限的可控，不同源的程序的隔离等&lt;/li&gt;
  &lt;li&gt;网路移动性：运行的状态，可执行的代码等 能在网路的不同节点中传递和执行，这是3种特性中的最高目标，前两种特性是这一特性的基本要求&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;java4-1&quot;&gt;Java平台通过4个技术的结合来实现其目标&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;java虚拟机&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;java虚拟机的主要功能是 加载class二进制(类加载器体系) 和 执行字节码(执行引擎)&lt;/p&gt;

&lt;p&gt;类加载器体系包括java平台默认实现的启动类加载器 和 用户实现的自定义类加载器，通过用户提供的类加载可以更加灵活的实现从不同地方(网路，文件系统，动态生成等) 动态地 加载类&lt;/p&gt;

&lt;p&gt;执行引擎有三种执行形式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解析执行&lt;/li&gt;
  &lt;li&gt;编译执行&lt;/li&gt;
  &lt;li&gt;自适应优化执行(动态编译高频率执行代码)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;java虚拟机是 java平台 实现 平台无关性，安全性和网路移动性 的核心&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Java虚拟机的功能有统一的规范，但不同平台上的实现可根据平台实现&lt;/li&gt;
  &lt;li&gt;不同的类加载加载的类在不同的命名空间，不能互相调用，实现隔离，所以安全&lt;/li&gt;
  &lt;li&gt;允许自定义的加载器从网路获取类所以实现网络移动性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;java class文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;java class文件更好的支持java平台的 平台无关性 和 网路移动性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java class是一种与平台无关的二进制服务形式(反例是c，c++的编译结果是平台相关的二进制代码)&lt;/li&gt;
  &lt;li&gt;java class文件格式紧凑，适合网路传输 和 按需下载，实现了网路移动性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;java API&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;java API(rt.jar等)更好的支持java平台的 平台无关性 和 安全性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java API封装了对底层系统资源的调用，对java程序提供统一的接口，实现平台无关&lt;/li&gt;
  &lt;li&gt;当java API进行任何潜在危险操作(硬盘io等)都会查询安全管理器和控制访问器来获取执行操作的权限&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;java语言&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java语言用来开发Java平台(平台无关，安全性，网络移动)应用&lt;/li&gt;
  &lt;li&gt;java语言是一种设计良好、开发效率高的语言，所以也非常适合用于开发不一定用到java平台特性的应用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;设计良好、开发效率的体现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是面向对象语言，所以比面向过程的抽象程度更高，更容易开发重用度更高的程序&lt;/li&gt;
  &lt;li&gt;垃圾收集，不用开发人员自己管理垃圾&lt;/li&gt;
  &lt;li&gt;去除指针概念，减少开发人员的失误&lt;/li&gt;
  &lt;li&gt;通过运行时类型检查抛异常来法制程序崩溃&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;java&quot;&gt;Java的劣势&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Java虚拟机执行速度可能较编译执行的程序慢&lt;/li&gt;
  &lt;li&gt;Java虚拟机的垃圾收集引入了性能的不确定性&lt;/li&gt;
  &lt;li&gt;Java虚拟机的线程管理说明模糊不清，使程序员无法了解如何调度线程&lt;/li&gt;
  &lt;li&gt;Java的平台无关性导致API的设计存在最小公分母问题&lt;/li&gt;
  &lt;li&gt;Java的class文件容易逆向工程，被窃取开发成果&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 08 Nov 2016 10:00:00 +0800</pubDate>
        <link>/2016/11/08/DEEP_IN_JAVA_VM__java_plateform/</link>
        <guid isPermaLink="true">/2016/11/08/DEEP_IN_JAVA_VM__java_plateform/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>面向对象系统的基本知识</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;面向对象的基本术语&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;面向对象系统的核心概念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;代码和功能的复用机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;面向对象设计的原则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对面向对象系统的基本知识的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;面向对象的基本术语&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;方法&lt;/strong&gt; 是一个操作或一个请求，包含名字，参数和返回值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接口&lt;/strong&gt; 是一系列方法的集合，对象可以拥有接口，所以接口体现了一个对象所能完成的功能&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类型&lt;/strong&gt; 是一个接口的名字，可以理解为等同于接口，类型可以有子类型和父类性，当一个类型包含另一个类型的时即为子类型&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类&lt;/strong&gt; 定义一个对象，提供（多个）类型里方法的实现，这是对象的一个静态写照&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对象&lt;/strong&gt; 面向对象系统里运行时的基本元素，通过各个对象之间的交互（互相发送请求消息）来实现面向系统的功能;对象之间可以相互交互，对象是一个类的实例化，可以拥有多个类型&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interfaced Duck { // 类型
	void quark() // 方法
}

class ConcreteDuck implements Duck { // 类，定义了Duck类型的实现
	static void quark() {
		// real quark
	}
	
	public static void main(String[] args) {1l
		Duck d1 = new ConcreteDuck();
		Duck d2 = new ConcreteDuck();
		
		d1.quark();
		d1.quark();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/runtime.png&quot; alt=&quot;runtime&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;面向对象系统的核心概念&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;封装&lt;/strong&gt; 把数据和对数据的操作聚合起来形成一个对象&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Duck { // 把name和quark封装成一个对象
	String name;
	
	void quark() {
		System.out.println(name + &quot; quarking...&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt; 包括两个含义&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类型继承：定义子类型，实现不同类型的替换&lt;/li&gt;
  &lt;li&gt;实现继承：实现代码的复用和实现的方法重定义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型继承举例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Quarkable {
	void quark()
}

interface Duck extends { // 类型继承
}

class ConcreteQuarkable implements Quarkable {}

class ConcreteDucke implements Quarkable {}

class Demo {
	static void runDemo(Quarkable q) {
		q.quark()
	}
	
	public static void main(String[] args) {1l
		runDemo(new ConcreteQuarkable());
		runDemo(new ConcreteDucke());
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实现继承举例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ConcreteQuarkable {
	void quark() { }
}

class ConcreteDucke1 extends ConcreteQuarkable { } // 继承了quark的实现

class ConcreteDucke2 extends ConcreteQuarkable {
	void quark() { }  // 重定义了quark的实现
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;多态&lt;/strong&gt; 在运行时动态的替换拥有相同类型的对象，如上类型继承举例&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;代码和功能的复用机制&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt; 可以实现代码的复用，缺点：这是在编译时实现的代码复用，所以是一种相对运行时来说的静态复用，不够灵活;子类会破坏父类的封装性，并对父类的代码产生依赖；优点是简单粗暴&lt;/p&gt;

&lt;p&gt;举例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class HashSet {
	...
	void addAll(Collection c) {
		for(Object o : i)
			add(o);
	}
	
	void add(Object o) {
		...
	}
	...
}

class BraokenSubSet { // broken cause dependency
	int counter = 0;

	@Override void add(Object o) { couter++; super.add(o); }
	
	@Override void addAll(Collection c) { couter += c.size(); super.addAll(c); }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;组合&lt;/strong&gt; 可以实现运行时的对象功能复用，通过多态能更加灵活; 缺点是会增加对象的数量导致增加运行时的复杂性&lt;/p&gt;

&lt;p&gt;举例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interfaced Duck {
	void quark()
}

class Demo {
	Duck d；
	
	Demo(Duck d) { this.d = d; }
	
	void setDuck(Duck d) { this.d = d; }
	
	void quark() { d.quark(); }
	
	public static void main(String[] args) {
		Demo demo = new Demo(new Duck(){
			void quark() {
				// implement version 1
			}
		});
		demo.quark();
		
		demo.setDuck((new Duck(){
			void quark() {
				// implement version 2
			}
		});
		demo.quark();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;委托&lt;/strong&gt; 通过组合来复用代码的功能，但又不需要继承&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Duck { void quark(); }

class ConcreteDucke1 extends Duck { 
	void quark() { }
}

class ConcreteDucke2 extends ConcreteQuarkable {
	ConcreteDucke1 d;
	
	ConcreteDucke2(ConcreteDucke1 d) { this.d = d; }
	
	void quark() { d.quark(); }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;参数化类型&lt;/strong&gt; 把类型作为一种可变的参数，是的代码不依赖于类型&lt;/p&gt;

&lt;p&gt;例如：List，Set，Map等&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;面向对象设计的原则&lt;/h2&gt;

&lt;p&gt;前提：视情况有取舍地使用这些原则，没有死规定&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;封装变化&lt;/strong&gt; 把可变的部分封装成对象&lt;/p&gt;

&lt;p&gt;例如：父类的两方法的实现在子类中存在着变化和重复时，应该单独封装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Bad example
class Duck {
	void fly() { System.out.println(&quot;Fly&quot;); }
	void quark() { System.out.println(&quot;quark&quot;); }
}

class ToyDuck extends Duck {
	@Override void fly() {}
	@Override void quark() { System.out.println(&quot;toy quark&quot;); }
}

class WildDuck extends Duck {
	@Override void fly() { System.out.println(&quot;Fly Height&quot;); }
	@Override void quark() { System.out.println(&quot;quark loudly&quot;); }
}

class CannotFlyWildDuck extends Duck {
	@Override void fly() {} // 重复的代码
	@Override void quark() { System.out.println(&quot;quark loudly&quot;); } // 重复的代码
}

// Good Example
interface Quarkable { void quark(); }

class Normal implements Quarkable { void quark() { System.out.println(&quot;quark&quot;); } }
class Silece implements Quarkable { void quark() {} }
class Loud implements Quarkable { void quark() { System.out.println(&quot;quark loudly&quot;); } }
class ToySound implements Quarkable { void quark() { System.out.println(&quot;toy quark&quot;); } }

abstract Duck {
	Quarkable q;
	Duck() { this.q = new Normal(); }
	void quark() { q.quark(); }
	
	void fly();
}

class Duck extends Duck {
	void fly() { System.out.println(&quot;Fly&quot;); }
}

class CannotFlyWildDuck extends Duck {
	@Override void fly() {}
}

class ToyDuck extends CannotFlyWildDuck {
	ToyDuck() { this.q = new ToySound(); }
}

class WildDuck extends Duck {
	WildDuck() { this.q = new Loud(); }
	@Override void fly() { System.out.println(&quot;Fly Height&quot;); }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;针对接口编程而非针对实现编程&lt;/strong&gt; 包括2个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户代码使用接口编程能获得动态替换具体实现的灵活性&lt;/li&gt;
  &lt;li&gt;接口的实现部分可以获得独立性和扩展性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;多用组合，少用继承&lt;/strong&gt; 对父类实现的依赖导致父类的修改影响到子类&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为了交互对象之间的松耦合设计而努力&lt;/strong&gt; 松耦合是指交互的对象之间不知道彼此的实现细节，只知道彼此拥有的接口，所以对象的具体实现的改变能互不影响&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开放–关闭原则&lt;/strong&gt; 已有代码应该对扩展开放，对修改关闭；集中精力实现最后可能改变的地方即可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;依赖倒置原则&lt;/strong&gt; 要依赖抽象的类型，不要依赖具体实现的类；编码时就是高层组件不要依赖底层组件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最少只是原则&lt;/strong&gt; 尽量减少对象间的相互依赖，否则动一发而动全身；要遵守这个原则就应该之访问以下范围内的对象的方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;该对象本身&lt;/li&gt;
  &lt;li&gt;作为参数传进来的对象&lt;/li&gt;
  &lt;li&gt;此方法所创建的对象&lt;/li&gt;
  &lt;li&gt;对象的组件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;好莱坞原则：别调用我们，我们调用你&lt;/strong&gt; 高层组件决定怎样使用提供给底层组件的钩子&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单一责任原则&lt;/strong&gt; 一个类应该只有一个引起变化的原因&lt;/p&gt;

</description>
        <pubDate>Thu, 20 Oct 2016 10:00:00 +0800</pubDate>
        <link>/2016/10/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</link>
        <guid isPermaLink="true">/2016/10/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</guid>
        
        <category>OO</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java虚拟机的构成</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#jvm&quot; id=&quot;markdown-toc-jvm&quot;&gt;JVM运行时&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;命令行解析&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;标注选项&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;非标准选项&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;非稳定选项&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vm&quot; id=&quot;markdown-toc-vm&quot;&gt;VM的启动和停止&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;类加载&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;加载&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;类加载器&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;分支主题&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;链接&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;类型安全&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;类初始化&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;类元数据&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;解析器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-13&quot; id=&quot;markdown-toc-section-13&quot;&gt;异常处理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-14&quot; id=&quot;markdown-toc-section-14&quot;&gt;线程同步&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-15&quot; id=&quot;markdown-toc-section-15&quot;&gt;线程管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#c&quot; id=&quot;markdown-toc-c&quot;&gt;C++堆管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;Java本地接口&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jvm-1&quot; id=&quot;markdown-toc-jvm-1&quot;&gt;JVM致命错误处理&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-16&quot; id=&quot;markdown-toc-section-16&quot;&gt;垃圾回收&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-17&quot; id=&quot;markdown-toc-section-17&quot;&gt;分代垃圾收集&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-18&quot; id=&quot;markdown-toc-section-18&quot;&gt;新生代&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#eden&quot; id=&quot;markdown-toc-eden&quot;&gt;Eden&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#survivor&quot; id=&quot;markdown-toc-survivor&quot;&gt;Survivor&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-19&quot; id=&quot;markdown-toc-section-19&quot;&gt;收集过程&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-20&quot; id=&quot;markdown-toc-section-20&quot;&gt;老年代&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-21&quot; id=&quot;markdown-toc-section-21&quot;&gt;永久代&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#serial&quot; id=&quot;markdown-toc-serial&quot;&gt;Serial垃圾收集器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#parallel&quot; id=&quot;markdown-toc-parallel&quot;&gt;Parallel垃圾收集器&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-22&quot; id=&quot;markdown-toc-section-22&quot;&gt;收集方法&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cms&quot; id=&quot;markdown-toc-cms&quot;&gt;并行标记清除(CMS)收集器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#g1&quot; id=&quot;markdown-toc-g1&quot;&gt;G1垃圾收集器&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jit&quot; id=&quot;markdown-toc-jit&quot;&gt;JIT编译器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对JVM 功能的简单汇总和简述，目标读者是想了解一下JVM功能&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;这是百度脑图编辑的本文内容要点，图后是内容简介&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/Java虚拟机的构成.svg&quot; alt=&quot;Java虚拟机的构成&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;jvm&quot;&gt;JVM运行时&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;命令行解析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;解析命令行的选项&lt;/li&gt;
  &lt;li&gt;配置VM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;选项分类&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;标注选项&lt;/h4&gt;

&lt;p&gt;JVM标注要求必须实现&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;非标准选项&lt;/h4&gt;

&lt;p&gt;(-X前缀)不强制实现&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;非稳定选项&lt;/h4&gt;

&lt;p&gt;(-XX前缀)为满足特定需求，不稳定&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数示例&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;-XX:+AffresiveOpts&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;+或-表示布尔类型的选项参数&lt;/li&gt;
  &lt;li&gt;后接JVM参数名字&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;-XX:OptName=&lt;N&gt;&lt;/N&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;JVM参数名字&lt;/li&gt;
  &lt;li&gt;后接=和value&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vm&quot;&gt;VM的启动和停止&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;启动器执行的操作&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;解析命令行参照&lt;/li&gt;
  &lt;li&gt;设置堆大小和JIT编译器&lt;/li&gt;
  &lt;li&gt;读取，设定环境变量&lt;/li&gt;
  &lt;li&gt;获取Main-Class&lt;/li&gt;
  &lt;li&gt;创建VM线程并初始化&lt;/li&gt;
  &lt;li&gt;加载Main-Class&lt;/li&gt;
  &lt;li&gt;执行main方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;类加载&lt;/h3&gt;

&lt;p&gt;根据类名或接口名创建对象的过程，包括3个阶段&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;加载&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;定位并读取类的二进制流&lt;/li&gt;
  &lt;li&gt;若一览其他类则先加载其他类&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-6&quot;&gt;类加载器&lt;/h5&gt;

&lt;h6 id=&quot;section-7&quot;&gt;分支主题&lt;/h6&gt;

&lt;h4 id=&quot;section-8&quot;&gt;链接&lt;/h4&gt;

&lt;p&gt;包括以下步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;检查类的语义，常量符号池；检验类型&lt;/li&gt;
  &lt;li&gt;创建静态字段并初始化为默认值&lt;/li&gt;
  &lt;li&gt;解析符合引用（可选）&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-9&quot;&gt;类型安全&lt;/h5&gt;

&lt;p&gt;Java类型由类加载器和全限定名(包括包名)唯一确定&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;类初始化&lt;/h4&gt;

&lt;p&gt;必须先初始化父类&lt;/p&gt;

&lt;h5 id=&quot;section-11&quot;&gt;类元数据&lt;/h5&gt;

&lt;p&gt;在永久代中创建Class对象的JVM内部表示&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;解析器&lt;/h3&gt;

&lt;p&gt;使用Template Table查找对应的机器码&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;异常处理&lt;/h3&gt;

&lt;p&gt;通过当前方法，当前字节码，异常对象来查找异常处理器并执行&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;线程同步&lt;/h3&gt;

&lt;p&gt;使用monitor对象实现锁定和解锁&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;线程管理&lt;/h3&gt;

&lt;h3 id=&quot;c&quot;&gt;C++堆管理&lt;/h3&gt;

&lt;h3 id=&quot;java&quot;&gt;Java本地接口&lt;/h3&gt;

&lt;p&gt;与非Java程序进行协作&lt;/p&gt;

&lt;h3 id=&quot;jvm-1&quot;&gt;JVM致命错误处理&lt;/h3&gt;

&lt;h2 id=&quot;section-16&quot;&gt;垃圾回收&lt;/h2&gt;

&lt;h3 id=&quot;section-17&quot;&gt;分代垃圾收集&lt;/h3&gt;

&lt;p&gt;原理&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;大对象生命周期短&lt;/li&gt;
  &lt;li&gt;生命周期长的对象很少引用生命周期短的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-18&quot;&gt;新生代&lt;/h4&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;空间小&lt;/li&gt;
  &lt;li&gt;收集频繁&lt;/li&gt;
  &lt;li&gt;垃圾对象多&lt;/li&gt;
  &lt;li&gt;垃圾收集效率高&lt;/li&gt;
  &lt;li&gt;一般使用复制垃圾收集法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;区域划分：Eden区和一对survivor区&lt;/p&gt;

&lt;h5 id=&quot;eden&quot;&gt;Eden&lt;/h5&gt;

&lt;p&gt;分配空间给新创建的对象&lt;/p&gt;

&lt;p&gt;空间分配方法：使用线程本地分配缓冲区和指针碰撞技术来分配空间创建对象&lt;/p&gt;

&lt;h5 id=&quot;survivor&quot;&gt;Survivor&lt;/h5&gt;

&lt;p&gt;存放从Eden存活但不足够老的对象&lt;/p&gt;

&lt;h5 id=&quot;section-19&quot;&gt;收集过程&lt;/h5&gt;

&lt;h4 id=&quot;section-20&quot;&gt;老年代&lt;/h4&gt;

&lt;p&gt;特点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对象从新生代晋升而来&lt;/li&gt;
  &lt;li&gt;空间比新生代大&lt;/li&gt;
  &lt;li&gt;占用空间增长速度较新生代慢&lt;/li&gt;
  &lt;li&gt;垃圾收集效率低&lt;/li&gt;
  &lt;li&gt;使用卡表来标记在新生代中对象的引用&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-21&quot;&gt;永久代&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;其实不作为垃圾收集分代层次的一部分&lt;/li&gt;
  &lt;li&gt;用户创建的对象不会存放在此&lt;/li&gt;
  &lt;li&gt;只存放元数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;serial&quot;&gt;Serial垃圾收集器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在新生代中使用赋值垃圾收集法&lt;/li&gt;
  &lt;li&gt;在老年代中使用标记-压缩收集法&lt;/li&gt;
  &lt;li&gt;单线程，stop-the-world收集&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;parallel&quot;&gt;Parallel垃圾收集器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;与Serial收集器的收集方法相同&lt;/li&gt;
  &lt;li&gt;使用多处理器并行收集&lt;/li&gt;
  &lt;li&gt;目标是高吞吐率&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-22&quot;&gt;收集方法&lt;/h4&gt;

&lt;h3 id=&quot;cms&quot;&gt;并行标记清除(CMS)收集器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;新生代使用复制收集法&lt;/li&gt;
  &lt;li&gt;老年代使用多步骤标记 和 清除 收集法&lt;/li&gt;
  &lt;li&gt;目标是高并发，减少停顿时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;老年代收集方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始标记：暂停应用程序，找出从外部可达的老年代对象并标记&lt;/li&gt;
  &lt;li&gt;不停顿，多线程从已标记的对象出发标记可达对象，并预清除&lt;/li&gt;
  &lt;li&gt;重新标记：暂停应用程序，多线程；并重用卡表进行重新标记&lt;/li&gt;
  &lt;li&gt;并发清除：维护空闲表，导致空间不连续和浪费，新生代回收开销增大&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;多次遍历老年代&lt;/li&gt;
  &lt;li&gt;需要更大的堆&lt;/li&gt;
  &lt;li&gt;有可能收集不干净&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;g1&quot;&gt;G1垃圾收集器&lt;/h3&gt;

&lt;h2 id=&quot;jit&quot;&gt;JIT编译器&lt;/h2&gt;

&lt;p&gt;在使用程序解析期间使用多种技术进行性能提升&lt;/p&gt;
</description>
        <pubDate>Thu, 22 Sep 2016 10:00:00 +0800</pubDate>
        <link>/2016/09/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B5%84%E6%96%99/</link>
        <guid isPermaLink="true">/2016/09/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B5%84%E6%96%99/</guid>
        
        <category>JVM</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Junit 4功能的简单汇总和简述</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;快速入门和浅尝&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#junit4&quot; id=&quot;markdown-toc-junit4&quot;&gt;Junit4功能汇总和简述&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#assertionsmatchers&quot; id=&quot;markdown-toc-assertionsmatchers&quot;&gt;Assertions和Matchers&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#assertiontext--text&quot; id=&quot;markdown-toc-assertiontext--text&quot;&gt;常用Assertion之一：断言text == text&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#matchersallof-equalto-startswith&quot; id=&quot;markdown-toc-matchersallof-equalto-startswith&quot;&gt;常用Matchers：allOf, equalTo, startsWith&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;测试用例的运行前初始化和运行后资源清理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;测试用例启动器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#junit&quot; id=&quot;markdown-toc-junit&quot;&gt;开发单元测试时，一些可重用的Junit功能组件的&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;理论：一种针对给一个单元测试用例定义各种可能的输入和前置条件的技术&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#junit-1&quot; id=&quot;markdown-toc-junit-1&quot;&gt;Junit的其他常用技术：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Junit 4功能的简单汇总和简述，目标读者是想了解一下Junit4了哪些测试工具的人员，所有代码和技术细节都是参考&lt;a href=&quot;https://github.com/junit-team/junit4/wiki#junit-usage-and-idioms&quot;&gt;Junit Wiki&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section&quot;&gt;快速入门和浅尝&lt;/h1&gt;
&lt;p&gt;此处不细说，直接参考简单明了的&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Getting-started&quot;&gt;Wiki&lt;/a&gt;吧，里面的内容就是Junit4 jar包的使用和运行简单测试实例，10分钟即可完成入门&lt;/p&gt;

&lt;h1 id=&quot;junit4&quot;&gt;Junit4功能汇总和简述&lt;/h1&gt;
&lt;p&gt;Junit4几乎所有功能官方汇总列表，可从此了解Junit4的各种功能，&lt;a href=&quot;https://github.com/junit-team/junit4/wiki&quot;&gt;官方Wiki&lt;/a&gt;相当简洁明了&lt;/p&gt;

&lt;p&gt;此处对较重要的功能稍微汇总，若有感兴趣的功能可到官方Wiki进一步了解：注意 所有代码出自Junit4 wiki&lt;/p&gt;

&lt;h2 id=&quot;assertionsmatchers&quot;&gt;Assertions和Matchers&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Assertions&quot;&gt;用法详情&lt;/a&gt;
这两种功能都是单元测试的技术基石，用来开发单元测试的断言，例如：&lt;/p&gt;

&lt;h5 id=&quot;assertiontext--text&quot;&gt;常用Assertion之一：断言text == text&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assertEquals(&quot;text&quot;, &quot;text&quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意：参数1是期望值，参数2是实际值&lt;/p&gt;

&lt;h5 id=&quot;matchersallof-equalto-startswith&quot;&gt;常用Matchers：allOf, equalTo, startsWith&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assertThat(&quot;good&quot;, allOf(equalTo(&quot;good&quot;), startsWith(&quot;good&quot;))); &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Matchers都用在assertThat断言中，代码的意思是：此处断言”good” 同时满足所有条件，条件分别是：与“good”相同，以“good”开头&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Matchers好处是：更符合断言语序，Matchers表达的比较语义更丰富和灵活，也易于开发人员扩展&lt;/strong&gt;
&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Matchers-and-assertthat&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;另：要测试 &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Exception-testing&quot;&gt;异常情况&lt;/a&gt; 是否符合预期行为;
要测试 &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Timeout-for-tests&quot;&gt;超时&lt;/a&gt; 是否符合预期行为&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;测试用例的运行前初始化和运行后资源清理&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Test-fixtures&quot;&gt;用法详情&lt;/a&gt;
主要使用&lt;strong&gt;@BeforeClass，@AfterClass, @Before 和 @After&lt;/strong&gt;来标注方法，这些标注都很容易理解&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@BeforeClass: 标注static类方法，用于对单元测试类中所有case都是用的资源进行初始化（一般用于初始化高成本资源），每个单元测试类只会运行一次&lt;/li&gt;
  &lt;li&gt;@AfterClass**：同上，功能是释放资源&lt;/li&gt;
  &lt;li&gt;@Before**：标注实例方法（单元测试用例）,用于对在每个单元测试用例运行前初始化一些变量或资源&lt;/li&gt;
  &lt;li&gt;@After**：同上，功能是释放资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;测试用例启动器&lt;/h2&gt;
&lt;p&gt;顾名思义，这些官方的启动器负责启动开发人员开发的测试用例，你可以根据用例所需要的不同功能来选择不同的启动器，官方的启动器有4个，不满足需求可以自己扩展；
此处稍微汇总
&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Test-runners&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IDE内置的单元测试启动器&lt;/strong&gt;：Eclipse，Netbeans等内置了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过命令行启动单元测试的启动器&lt;/strong&gt;：org.junit.runner.JUnitCore；使用的时候直接在命令行窗口跑单元测试
&lt;strong&gt;** JUnit4TestAdapter&lt;/strong&gt;: 在Junit3的启动器中运行 用Junit4开发的单元测试 时使用的Junit4启动器adapter&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用@RunWith来注解的class来作为单元测试启动器&lt;/strong&gt;：可以在注解里赋值来指定Junit内置的几个启动器，例如：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;1. 把一堆单元测试用例定义成一整套单元测试&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites&quot;&gt;用法详情&lt;/a&gt;*&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(Suite.class) // Sute.class是Junit的启动器
@Suite.SuiteClasses({  //里面的class都是开发人员开发的一些单元测试
	TestFeatureLogin.class,
	TestFeatureLogout.class,
	TestFeatureNavigate.class,
	TestFeatureUpdate.class
})
public class FeatureTestSuite {
	// the class remains empty,
	// used only as a holder for the above annotations
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;2. 给一个测试用例提供不同的参数&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Parameterized-tests&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(Parameterized.class)
public class FibonacciTest {
    @Parameters
    public static Collection&amp;lt;Object[]&amp;gt; data() {
        return Arrays.asList(new Object[][] {     
                 { 0, 0 }, { 1, 1 }, { 2, 1 }, { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 }  
           });
    }

    private int fInput;

    private int fExpected;

    public FibonacciTest(int input, int expected) {
        fInput= input;
        fExpected= expected;
    }

    @Test
    public void test() {
        assertEquals(fExpected, Fibonacci.compute(fInput));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;3. 把不同的单元测试用例弄成不同分类，然后使用 分类启动器 启动不同类别的单元测试&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Categories&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;4. 还有一些其他实验性和第三方启动器&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Test-runners#experimental-runners&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;5. 理论启动器：用于启动使用了“理论”技术开发单元测试的启动器，可参考下文对理论的简述&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Theories&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;junit&quot;&gt;开发单元测试时，一些可重用的Junit功能组件的&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Rules&quot;&gt;用法详情&lt;/a&gt;
通过@Rule注解来标注所使用的 组件，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Rule
public TemporaryFolder tempFolder = new TemporaryFolder();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Rule的原理是Junit在初始化一个单元测试类的时候会实例化一个@Rule标注的 rule域实例，并在每个case运行的时候都会调用 rule域实例的evaluate方法&lt;/p&gt;

&lt;p&gt;Junit所提供的组件包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TemporaryFolder：提供在测试时生成临时目录和文件的功能组件&lt;/li&gt;
  &lt;li&gt;ExternalResource：提供在测试时 自定义一些外部资源（数据库连接，socket等） 的基类，实现它提供具体的资源&lt;/li&gt;
  &lt;li&gt;ErrorCollector：测试过程中对 自认为的错误状态进行收集的工具&lt;/li&gt;
  &lt;li&gt;Verifier：提供 自定义条件校验器 的基类，实现它提供具体的校验&lt;/li&gt;
  &lt;li&gt;TestWatcher：使用它能在Junit运行每个单元测试用例的每个步骤时得到通知，从而收集用例的测试状态信息&lt;/li&gt;
  &lt;li&gt;TestName：获取测试用例名称&lt;/li&gt;
  &lt;li&gt;Timeout：测试 超时 是否符合预期行为&lt;/li&gt;
  &lt;li&gt;ExpectedException：测试 异常情况 是否符合预期行为&lt;/li&gt;
  &lt;li&gt;ClassRule：标注类的域，一般是定义一些对整个单元测试类的所有单元测试用例都有影响的域（例如外部资源等），这里不细述，请参考&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Rules&quot;&gt;用法详情&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;RuleChain：声明Rule链，链里的Rule是有顺序的&lt;/li&gt;
  &lt;li&gt;另外，可以实现TestRule接口来定制自己的Rule&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;理论：一种针对给一个单元测试用例定义各种可能的输入和前置条件的技术&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Theories&quot;&gt;用法详情&lt;/a&gt;
使用这种启动器，你可以定义测试用例的所有前置条件（不满足前置条件则忽略这个测试用例），以及不同的测试输入参数&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;junit-1&quot;&gt;Junit的其他常用技术：&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Ignoring-tests&quot;&gt;忽略（跳过）某些测试用例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Assumptions-with-assume&quot;&gt;对测试用例定义运行的先决条件 assumptions（不满足会自动跳过测试用例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Multithreaded-code-and-concurrency&quot;&gt;多线程，并发测试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Continuous-testing&quot;&gt;持续集成和测试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki#junit-usage-and-idioms&quot;&gt;maven和grade&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 21 Sep 2016 10:00:00 +0800</pubDate>
        <link>/2016/09/21/how-to-use-junit/</link>
        <guid isPermaLink="true">/2016/09/21/how-to-use-junit/</guid>
        
        <category>Junit</category>
        
        
        <category>技术</category>
        
      </item>
    
  </channel>
</rss>
