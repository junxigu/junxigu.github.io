<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>个人技术博客</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 04 Jan 2017 16:52:20 +0800</pubDate>
    <lastBuildDate>Wed, 04 Jan 2017 16:52:20 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Java项目性能优化简介</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;性能问题的现状&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;性能分析的两种方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;改善性能的3种活动&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java项目性能优化的基本知识的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;性能问题的现状&lt;/h2&gt;

&lt;p&gt;传统的项目开发过程：分析-&amp;gt;设计-&amp;gt;编码-&amp;gt;测试，缺少对性能问题的考虑，导致开发出来的系统很可能不符合性能的需求&lt;/p&gt;

&lt;p&gt;应该在分析的阶段就提炼出性能的需求，以用例的形式表达处理，在设计阶段加以考虑潜在的新能问题，并在测试阶段之前增加性能测试用例和分析来弥补，所以最终的开发流程是：&lt;br /&gt;
分析-&amp;gt;设计-&amp;gt;编码-&amp;gt;性能测试-&amp;gt;测试&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;性能分析的两种方法&lt;/h2&gt;

&lt;p&gt;通过从不同的方向来寻找可优化的空间&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自顶向下：从应用层-&amp;gt;容器-&amp;gt;虚拟机-&amp;gt;… 来寻找可优化的空间，通过监控应用，容器，操作系统的性能数据找出问题所在，执行某些措施来优化性能&lt;/li&gt;
  &lt;li&gt;自底向上：从CPU-&amp;gt;操作系统-&amp;gt;.. 通过监控底层的信息来发现不同架构中应用的性能差异，对环境根据性能分析数据来调优；例如一定负载下CPU的指令数，高速缓存未命中率等，通过某些措施(如使用JIT编译器优化机器码)来改善硬件和操作系统的性能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;很多时候，CPU的架构会对应用的性能起到关键的影响，所以需要恰当的选择,例如多核和每核多硬件线程比多CPU更适合需要大量线程的应用，因为当CPU就绪，而某个硬件线程所需的资源未就绪时，可以在下一个时钟周期内切换到同CPU中的另一个硬件线程，而单硬件线程的CPU切换线程需要耗费数百个时钟周期；&lt;br /&gt;
另一方面，多硬件线程的CPU的时钟频率比较慢，所以当应用所需的线程不多时，单硬件线程的CPU的性能要比多硬件线程的CPU要好&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;改善性能的3种活动&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;性能监控：以非浸入式的方式收集和查看应用的性能数据&lt;/li&gt;
  &lt;li&gt;性能分析：以浸入式的方式收集运行性能数据，会对应用的延迟和吞吐率产生影响，集中于被报告的性能问题&lt;/li&gt;
  &lt;li&gt;性能调优：通过更改运行配置参数，代码等多种方式来改善应用的性能，一般在性能监控和性能分析后进行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;《Java性能优化权威指南》&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Jan 2017 10:00:00 +0800</pubDate>
        <link>/2017/01/04/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97_%E7%AD%96%E7%95%A5-%E6%96%B9%E6%B3%95%E5%92%8C%E6%96%B9%E6%B3%95%E8%AE%BA/</link>
        <guid isPermaLink="true">/2017/01/04/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97_%E7%AD%96%E7%95%A5-%E6%96%B9%E6%B3%95%E5%92%8C%E6%96%B9%E6%B3%95%E8%AE%BA/</guid>
        
        <category>性能优化</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>操作系统系能监控简介</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;操作系统性能数据的监控&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#cpu&quot; id=&quot;markdown-toc-cpu&quot;&gt;CPU使用率&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cpu-1&quot; id=&quot;markdown-toc-cpu-1&quot;&gt;CPU调度程序运行队列&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;内存使用率&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;监控锁竞争&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;监控抢占式上下文切换&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#io&quot; id=&quot;markdown-toc-io&quot;&gt;监控网路I/O使用率&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#io-1&quot; id=&quot;markdown-toc-io-1&quot;&gt;磁盘I/O使用率&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对操作系统系能监控的基本知识的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;性能监控的关键在于知道该监控什么数据&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;操作系统性能数据的监控&lt;/h2&gt;

&lt;p&gt;操作系统自带一些长期收集系统性能数据的日志工具如：sar，kstat，cpustat等&lt;/p&gt;

&lt;h3 id=&quot;cpu&quot;&gt;CPU使用率&lt;/h3&gt;

&lt;p&gt;CPU使用率分为两种，一种是用户态，一种是系统态&lt;br /&gt;
用户态使用率是指应用使用CPU所占的比率，而系统态是进行系统调用时消耗CPU的比率&lt;br /&gt;
系统态CPU使用意味着共享资源的竞争，I/O设备之间的交互，所以要想提高性能应该尽量降低系统态CPU的使用&lt;br /&gt;
另外，对于计算密集型的应用还需要监控每时钟指令数，查看是否存在浪费CPU时钟周期的因素(如高速缓存未命中)等，但这需要特别的监控工具&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Windows：Task Manager，Performance Monitor，Windows typeperf &lt;br /&gt;
Linux：System Monitor，vmstat，mpstat，top，jstack&lt;br /&gt;
Solaris：System Monitor，cpubar，vmstat，mpstat，prstat，jstack&lt;/p&gt;

&lt;h3 id=&quot;cpu-1&quot;&gt;CPU调度程序运行队列&lt;/h3&gt;

&lt;p&gt;运行队列中是就绪的任务，它们在等待CPU的调度，如果准备运行的轻量级进程数超过系统能处理(硬件线程数)的上限，运行队列就会很长&lt;br /&gt;
改善的方法是：一、增加CPU数，二、改善算法和数据结构来减少线程对CPU使用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Windows：Performance Monitor，typeperf &lt;br /&gt;
Solaris：cpubar，vmstat &lt;br /&gt;
Linux：vmstat&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;内存使用率&lt;/h3&gt;

&lt;p&gt;需要监控系统内存的相关属性：页面调度、页面交换、加锁、线程上下文切换等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Windows：Performance Monitor，typeperf&lt;br /&gt;
Solaris：vmstat&lt;br /&gt;
Linux：vmstat&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;监控锁竞争&lt;/h3&gt;

&lt;p&gt;锁竞争导致线程的让步式上下文切换，耗费大量的时钟&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Windows：借助外部工具Performance Analyzer&lt;br /&gt;
Solaris：mpstat&lt;br /&gt;
Linux：pidstat&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;监控抢占式上下文切换&lt;/h3&gt;

&lt;p&gt;抢占式上下文切换表明线程数大于硬件线程数&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Windows：Task Manager等&lt;br /&gt;
Solaris：mpstat，prstat&lt;br /&gt;
Linux：pidstat&lt;/p&gt;

&lt;h3 id=&quot;io&quot;&gt;监控网路I/O使用率&lt;/h3&gt;

&lt;p&gt;当应用不能高效使用网路I/O就会导致数据进入操作系统的缓冲，导致延迟&lt;/p&gt;

&lt;p&gt;可用用NIO库提高Java应用的网路I/O性能&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Windows：Task Manager等&lt;br /&gt;
Solaris：nicstat&lt;br /&gt;
Linux：nicstat&lt;/p&gt;

&lt;h3 id=&quot;io-1&quot;&gt;磁盘I/O使用率&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Windows：Performance Monitor&lt;br /&gt;
Solaris：iostat&lt;br /&gt;
Linux：iostat&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;《Java性能优化权威指南》&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Jan 2017 10:00:00 +0800</pubDate>
        <link>/2017/01/04/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</link>
        <guid isPermaLink="true">/2017/01/04/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</guid>
        
        <category>性能监控</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java应用性能分析简介</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;方法分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;内存分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;性能优化机会&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java应用性能分析的基本知识的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Java应用的性能分析主要包括 方法分析，锁竞争分析 和 内存分析&lt;/p&gt;

&lt;p&gt;主要的分析工具包括：Performance Analyzer, VisualVM&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;方法分析&lt;/h2&gt;

&lt;p&gt;方法分析工具抓取到的信息中，一般查看的数据包括：&lt;br /&gt;
方法占用的用户态CPU时间，独占用户态CPU时间&lt;br /&gt;
方法间的调用关系&lt;/p&gt;

&lt;p&gt;通过分析方法的占用时间来定位导致系统瓶颈的嫌疑方法&lt;br /&gt;
例如，某些方法使用了运行与系统态的I/O，消耗了大量时间，可以考虑用缓冲或更高效I/O库来进行优化&lt;br /&gt;
例如，某些方法因为锁竞争浪费大量CPU时间，考虑考虑用更高效的并发数据结构，或消除竞争等方法来优化&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;内存分析&lt;/h2&gt;

&lt;p&gt;通过分析工具可以抓取到，内存中各种对象的内存占用量，可以通过分析某些占用内存较多对象存活的代数来定位是否存在内存泄漏，并能定位创建这些对象的方法来定位内存泄漏的代码&lt;/p&gt;

&lt;p&gt;JVM在发生OOM时会生成一个堆转存，这是一个内存的快照，可以通过上述工具来对当时的内存进行分析，找出内存泄漏的地方&lt;/p&gt;

&lt;p&gt;通过内存分析能还可以发现是否存在因不合理的初始设置大量创建没用的小对象的集合数据结构，通过优化初始设置来优化这些集合数据结构的使用&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;性能优化机会&lt;/h2&gt;

&lt;p&gt;对Java应用性能优化的机会主要有3种&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用更高效的算法&lt;/li&gt;
  &lt;li&gt;减少锁竞争&lt;/li&gt;
  &lt;li&gt;为算法生成更有效率的代码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当通过性能分析找到影响应用性能的根源时，主要通过这3种方法来优化&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;《Java性能优化权威指南》&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Jan 2017 10:00:00 +0800</pubDate>
        <link>/2017/01/04/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97_Java%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">/2017/01/04/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97_Java%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
        
        <category>性能分析</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>JVM性能调优入门</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;应用的系统需求&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jvm&quot; id=&quot;markdown-toc-jvm&quot;&gt;JVM调优的步骤&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jvm-gc&quot; id=&quot;markdown-toc-jvm-gc&quot;&gt;JVM GC调优&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#gc&quot; id=&quot;markdown-toc-gc&quot;&gt;GC的自适应调优&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#gc-1&quot; id=&quot;markdown-toc-gc-1&quot;&gt;并行GC调优建议&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#g1&quot; id=&quot;markdown-toc-g1&quot;&gt;G1调优建议&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#gc-2&quot; id=&quot;markdown-toc-gc-2&quot;&gt;复杂的GC调优&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#gcjvm&quot; id=&quot;markdown-toc-gcjvm&quot;&gt;调优GC并确定JVM内存使用量&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#gc-3&quot; id=&quot;markdown-toc-gc-3&quot;&gt;调优GC延迟&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#gc-4&quot; id=&quot;markdown-toc-gc-4&quot;&gt;对并行GC的调优&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#cms&quot; id=&quot;markdown-toc-cms&quot;&gt;对CMS的调优&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#gc-5&quot; id=&quot;markdown-toc-gc-5&quot;&gt;调优GC的吞吐量&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#gc-6&quot; id=&quot;markdown-toc-gc-6&quot;&gt;GC调优用到的命令行参数&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对JVM性能调优的基本知识的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;为什么需要JVM调优？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JVM上运行的应用多种多样，JVM为了满足应用不同的行为特征和性能需求，提供了很多配置，应用可以按照其特点来配置JVM获得更好的性能&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么是JVM调优？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据应用的行为特征来配置JVM的启动参数，让应用获得其需要的性能&lt;br /&gt;
性能数据一般包括：应用启动时间，内存使用量，吞吐率，延迟&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;应用的系统需求&lt;/h2&gt;

&lt;p&gt;在进行JVM调优之前，首先要确定应用的系统需求，这个需求应该在设计阶段已经定义好了，系统需求包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;吞吐量：单位时间内应用处理的工作量&lt;/li&gt;
  &lt;li&gt;响应时间：是指不考虑吞吐量的影响，应用接收到指令后开始工作直到完成的时长，&lt;/li&gt;
  &lt;li&gt;内存消耗：同等的吞吐量，响应时间，可用性和可管理性的条件下的内存消耗&lt;/li&gt;
  &lt;li&gt;启动时间：应用初始化所需要的时间&lt;/li&gt;
  &lt;li&gt;可用性：可以理解成健壮性，当系统的某些部分不能工作以后不会影响到系统的其他部分&lt;/li&gt;
  &lt;li&gt;可管理性：对维护，运行，部署系统所产生的开销，可用性的提高很可能会牺牲掉可管理型&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jvm&quot;&gt;JVM调优的步骤&lt;/h2&gt;

&lt;p&gt;根据定好的系统需求按照流程来对JVM进行调优，调优时应针对系统运行进入稳定阶段的运行情况来调优，以下是JVM调优的步骤(图源自《Java性能优化权威指南》)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/JVM调优工作流程.png&quot; alt=&quot;JVM调优的步骤&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;JVM调优涉及到多种系统需求，每个需求其实是一个取舍，为了满足某个需求必定为牺牲另外一个需求，所以在调优之前应该清除不同系统需求之间的优先级&lt;/li&gt;
  &lt;li&gt;接着是根据 可用性，可管理性和内存使用量 来确定JVM部署模式，在单个JVM上部署应用能增加应用的可管理性，但不利于应用的可用性和单个JVM的内存使用量&lt;/li&gt;
  &lt;li&gt;接着是根据 吞吐量、响应时间、启动时间，内存使用量 来选择JVM运行时，例如Server JVM能更好的满足吞吐量和响应时间，但牺牲了启动时间来进行优化，32位的JVM能提供更快启动时间和更少内存使用量&lt;/li&gt;
  &lt;li&gt;然后按步骤根据内存使用量、应用的停顿和应用的吞吐量 来对JVM的GC进行调优&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于调优的某个过程会影响到先前的系统需求、或者为了达到某个需求需要调整以前步骤的调优，所以调优的过程是一个重复多次步骤的过程&lt;/p&gt;

&lt;h2 id=&quot;jvm-gc&quot;&gt;JVM GC调优&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;优化GC是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GC是个自动的内存管理工具，它根据一些参数来调整自己的行为，比如触发垃圾收集的阈值等&lt;/p&gt;

&lt;p&gt;CG优化就是通过改变某些参数来使得GC的行为让应用程序的性能指标(吞吐率和延迟)达到用户预期&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么需要优化GC？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般情况下，JVM会根据机器的性能选用某种合适的GC，并根据应用运行情况动态地对GC进行一定的优化，但当应用有特别的需求时，开发人员应该根据应用的特殊情况来选择合适的GC并进行人工优化&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么样优化GC？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JVM根据不同的应用和应用的不同行为来调整其功能，尽量使应用的吞吐率和延迟达到一个平衡&lt;/p&gt;

&lt;p&gt;GC调优按照应用的需求程度能有不同的调优方法，这些方法从简单到复杂，对应用的性能需求越严格需要进行调整的参数越多&lt;/p&gt;

&lt;p&gt;JVM GC调优主要是面向3个性能需求属性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;吞吐量: 不考虑停顿时长和内存占用，垃圾收集器能支撑的应用程序的任务量&lt;/li&gt;
  &lt;li&gt;延迟：垃圾收集器导致的应用停顿时长&lt;/li&gt;
  &lt;li&gt;内存占用：垃圾收集器顺畅运行所用的内存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些属性都是不可兼得的，只能取舍&lt;/p&gt;

&lt;h3 id=&quot;gc&quot;&gt;GC的自适应调优&lt;/h3&gt;

&lt;p&gt;GC的自适应调优对人来说是最简单的，需要的工作量最少，这种调优方法叫人类工程学(Ergonomics 有道翻译)，简单地说就是JVM根据 &lt;em&gt;应用类型&lt;/em&gt; 、应用的运行情况和 &lt;em&gt;性能指标&lt;/em&gt; 来对JVM和GC进行配置和调整&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JVM按照应用类型配置默认功能&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;应用类型&lt;/em&gt;&lt;br /&gt;
按照运行应用的机器性能来把应用分成两类：client型和server型；运行在 &amp;gt;1 CPU，&amp;gt;1GB 内存 的机器上的应用就属于server型&lt;/p&gt;

&lt;p&gt;JVM为不同类型的应用提供了不同的默认JVM功能配置，这些默认JVM功能包括：GC的种类，Java堆大小，运行时编译器  &lt;br /&gt;
server型的默认配置是 并行GC，[1/64总内存大小, 1/4总内存大小]的Java堆，server型运行时编译器&lt;br /&gt;
不同的硬件平台具体的默认配置请参考&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#ergonomics&quot;&gt;HotSpot优化指南&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;gc-1&quot;&gt;并行GC调优建议&lt;/h4&gt;

&lt;p&gt;并行GC还会根据应用程序的运行情况和性能需求在初始大小和最大值中自动调整Java堆的大小&lt;/p&gt;

&lt;p&gt;性能需求包括3方面：吞吐率，最大停顿时间 和 内存占用量&lt;br /&gt;
可以通过-XX:MaxGCPauseMillis=&lt;nnn&gt;来配置应用的最大停顿时间，通过-XX:GCTimeRatio=&lt;nnn&gt;来配置应用的吞吐率，-XX:Xmx设置最大内存占用，GC会根据以上参数来调整堆大小，使其满足最大停顿延迟，尽量满足吞吐率，并尽量减少内存占用&lt;/nnn&gt;&lt;/nnn&gt;&lt;/p&gt;

&lt;p&gt;注意，只有并行GC支持以上最大停顿时间和吞吐率的配置参数，其他GC不支持；另外，上述性能需求时互相牵制的不可能同时满足，需要进行一定的取舍

&lt;strong&gt;GC自适应调优建议&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;除非知道应用所需的堆比默认最大堆大，否则不要指定堆的最大值&lt;/li&gt;
  &lt;li&gt;当GC达到最大堆还不能满足吞吐率时则需要调整最大堆的默认值了&lt;/li&gt;
  &lt;li&gt;当不能忍受GC的停顿时长时需要设置最大停顿时长，但这导致现有的吞吐量的下降&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;g1&quot;&gt;G1调优建议&lt;/h4&gt;

&lt;p&gt;G1跟并行GC一样是一种自适应GC，所以最简单的方法就是通过设置其XX:G1NewSizePercent来满足最大停顿时长的需求，设置XX:InitiatingHeapOccupancyPercent、XX:G1MixedGCLiveThresholdPercent、XX:G1MixedGCCountTarget、XX:G1HeapWastePercent、XX:G1OldCSetRegionThresholdPercent来满足吞吐率的需求，设置XX:Xmx来满足内存占用的需求&lt;/p&gt;

&lt;p&gt;当出现Survivor或to-space溢出时，说明Major GC不够早，或者不够快，这时可以&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设置XX:G1ReservePercent来增大预留空间&lt;/li&gt;
  &lt;li&gt;降低XX:InitiatingHeapOccupancyPercent来提早Major GC&lt;/li&gt;
  &lt;li&gt;增加XX:ConcGCThreads来使Major GC收集更快&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当出现大量巨无霸对象时，可以考虑设置XX:G1HeapRegionSize来增大块来减少分配巨无霸对象&lt;/p&gt;

&lt;p&gt;G1调优时避免固定新生代的大小，这样会覆盖最大停顿时间配置&lt;/p&gt;

&lt;h3 id=&quot;gc-2&quot;&gt;复杂的GC调优&lt;/h3&gt;

&lt;p&gt;当GC的自适应调优不能满足应用的性能需求时就有必要进行更细致的调优&lt;br /&gt;
调优手段包括利用JVM的监控命令参数来打印GC的各种信息，根据性能需求调整GC的堆大小和各个代的大小，根据应用的性能需求和行为选择GC的种类&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;根据性能需求选择GC的种类的建议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当应用数据集少于100M时使用序列化GC&lt;br /&gt;
当应用是部署到一个核心的机器上并且没有停顿时间的需求时使用序列化GC&lt;br /&gt;
当应用追求高吞吐率而不特别关心停顿时间时选用并行GC
当应用停顿时间比吞吐率重要是选用CMS或G1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;堆大小和代大小的调优&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在根据性能需求和应用的行为特点选择了一种GC以后，可以通过调整堆和代的大小来调整应用的停顿和吞吐率，由于不同的的GC有各自的特点，所以其调优的方法和重点不一样&lt;/p&gt;

&lt;h3 id=&quot;gcjvm&quot;&gt;调优GC并确定JVM内存使用量&lt;/h3&gt;

&lt;p&gt;首先要确定GC所需要的内存使用量，然后作为参考来确定JVM的内存使用量是否合适 &lt;br /&gt;
通过获取活跃数据的大小能确定GC所需的内存使用量&lt;br /&gt;
Java堆大小并不代表Java应用程序大小，堆大小只是一部分，还包括调用栈大小，线程开销，io缓存，第三方库分配内存等，若JVM内存使用量超过机器所能分配的内存大小，则需要重新执行以前的步骤来调整需求&lt;/p&gt;

&lt;p&gt;活跃数据的大小是应用程序稳定运行时长期存活的对象占用的java堆大小，包括稳定阶段Major GC后的老年代和永久代占用的空间；&lt;/p&gt;

&lt;p&gt;首先通过给应用足够的负载来让Java堆进入稳定状态，若出现OOME，则说明最大堆大小设置太小了，增大堆大小来让GC正常运行&lt;br /&gt;
当GC经过多次Major GC后，用工具或命令行来算出多次Major GC后老年代中的占用量和永久代的占用量，这就是老年代和永久代的活跃数据的大小&lt;br /&gt;
获得活跃数据的大小后，一般可以按照3~4倍老年代活跃数据设置老年代，1.2~1.5倍永久代数据设置永久代，1~1.5倍老年代活跃数据设置新生代&lt;/p&gt;

&lt;p&gt;经过调整Java堆大小，对JVM内存大小的影响则取决于应用的因素了&lt;/p&gt;

&lt;h3 id=&quot;gc-3&quot;&gt;调优GC延迟&lt;/h3&gt;

&lt;p&gt;对应用的延迟制定的系统需求主要包括4点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;应用可接受的平均停滞时间&lt;/li&gt;
  &lt;li&gt;可接受的Minor GC频率&lt;/li&gt;
  &lt;li&gt;可接受的应用最大停顿&lt;/li&gt;
  &lt;li&gt;可接受的最大停顿频率&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;与系统需求相对应的GC延迟包括&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Minor GC的持续时间：对应应用可接受的平均停滞时间&lt;/li&gt;
  &lt;li&gt;Minor GC的频率：对应可接受的Minor GC频率&lt;/li&gt;
  &lt;li&gt;Major GC的持续时间：对应可接受的应用最大停顿&lt;/li&gt;
  &lt;li&gt;Major GC的频率：对应可接受的最大停顿频率&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新生代越大Minor GC的平均时长越长而频率越低，老年代越大Full GC的平均时长越长而频率越低；所以通过调整新生代，老年代的大小来调整延迟或频率；&lt;/p&gt;

&lt;p&gt;通过调整GC的参数来使上述GC延迟满足系统的延迟需求&lt;br /&gt;
根据Minor GC的持续时间和频率调整新生代的大小，根据Full GC的持续时间和频率调整老年代的大小和决定是否需要切换到新的垃圾收集器&lt;/p&gt;

&lt;h4 id=&quot;gc-4&quot;&gt;对并行GC的调优&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;第一步，调整新生代大小&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据log里的Minor GC的持续时间、Minor GC的频率来调整新生代(更细粒度的说是Eden)的大小来满足应用可接受的平均停滞时间和可接受的Minor GC频率&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二步，调整老年代大小&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据log里的Major GC的持续时间、Major GC的频率来调整老年代的大小来满足可接受的应用最大停顿和可接受的最大停顿频率&lt;/p&gt;

&lt;p&gt;在调优老年代大小时，可以根据Full GC的时间戳和持续时间来确定延迟和频率；若log中没有Full GC，则可以通过15次Minor GC以后的Minor GC的记录来推算Full GC中对象的提升率，从而推断出Full GC的频率&lt;/p&gt;

&lt;p&gt;调整堆大小时需要符合几个准则：老年代大小至少是活跃数据的1.5倍，新生代至少为堆大小的10%，JVM大小不能超过可用物理内存；&lt;/p&gt;

&lt;h4 id=&quot;cms&quot;&gt;对CMS的调优&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;第一步，调整Survivor&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于CMS，为了减少CMS出现压缩式的Full GC，需要通过更精细的调整Survivor来减少不必要的对象提升到老年代，为此需要通过日志观察新生代中的对象年龄分布，找到合适的Survivor大小来保证年轻的对象都会在Minor GC中被收集&lt;/p&gt;

&lt;p&gt;注意，调整Survivor时应尽量保证Eden和老年代的大小不会减少&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二步，调整老年代&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了使老年代尽量少发生压缩式Full GC，主要是通过调整触发Major GC的老年代空间占用率 -XX:CMSInitiatingOccupancyFraction来控制进行Major GC的频率，对于占用率的调整主要依据两个因素&lt;br /&gt;
活跃数据的大小：占用率的设置不应小于活跃数据的大小，否则会不停触发Major GC&lt;br /&gt;
老年代对象的提升速率：并发Major GC清理对象的速率不要跟提升速率相差太大，过早的Major GC效率低，过晚的Major GC会引发CMF&lt;/p&gt;

&lt;p&gt;通过调整并行remark的线程数来调整最大停顿延迟&lt;/p&gt;

&lt;p&gt;可以考虑对永久代开启并发收集来减少产生Full GC的频率&lt;/p&gt;

&lt;p&gt;若经过调优后，GC所引起的延迟不能达到预期，能通过两种方法来减少堆内对象的分配率，从而降低延迟&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对应用进行性能分析，分析其堆占用，减少对象的分配和保持&lt;/li&gt;
  &lt;li&gt;改变JVM的部署模式，减少单个JVM的负荷&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gc-5&quot;&gt;调优GC的吞吐量&lt;/h3&gt;

&lt;p&gt;调优吞吐量其实就是尽量降低Minor GC和Full GC的频率，例如可以是增大Eden空间降低Minor GC频率，例如增大Survivor空间来让提升发生之前都被Minor GC收集了，例如增大老年代来降低Full GC频率等&lt;/p&gt;

&lt;p&gt;另外还需要调整并发GC使用的CPU数量来控制GC对应用吞吐率的影响&lt;/p&gt;

&lt;h3 id=&quot;gc-6&quot;&gt;GC调优用到的命令行参数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;优化GC时一般用到的监控命令行参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;-verbose:gc 输出垃圾收集信息&lt;br /&gt;
-XX:+PrintGCDetails 输出GC详细信息&lt;br /&gt;
-XX:+PrintGCTimeStamps 输出时间戳&lt;br /&gt;
-XX:+PrintGCDateStamps 输出日期&lt;br /&gt;
-Xloggc:&lt;filename&gt; 输出到文件  
-XX:+PrintTenuringDistribution 输出Survivor中对象的年龄分布  
-XX:+PrintGCApplicationConcurrentTIme 报告application在安全点之间的运行时间  
+XX:+PrintGCApplicationStoppedTime 报告application线程被阻塞的时间  
-XX:+PrintFlagsFinal 打印JVM使用的启动参数&lt;/filename&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优化GC时一般用到的调优命令行参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;-Xms 初始堆大小&lt;br /&gt;
-Xmx 堆最大的大小&lt;br /&gt;
-XX:MinHeapFreeRatio 堆最小空比例，当堆的剩余空间少于这个比例则增大堆空间(不适用于并行GC)&lt;br /&gt;
-XX:MaxHeapFreeRatio 堆最大空比例，当堆的剩余空间大于这个比例则减少堆空间(不适用于并行GC)&lt;br /&gt;
-XX:NewRatio 老年代空间比新生代空间&lt;br /&gt;
-XX:NewSize 新生代初始空间大小&lt;br /&gt;
-XX:MaxNewSize 新生代最大空间大小&lt;br /&gt;
-XX:SurvivorRatio Eden空间比一个Survivor空间&lt;br /&gt;
-XX:+UseSerialGC 使用序列化GC&lt;br /&gt;
-XX:+UseParallelGC 使用并行GC&lt;br /&gt;
-XX:+UseConcMarkSweepGC 使用CMS&lt;br /&gt;
-XX:+UseG1GC 使用G1&lt;/p&gt;

&lt;p&gt;-XX:GCTimeRatio  设置并行GC收集时长和应用运行时长的比例&lt;br /&gt;
-XX:ParallelGCThreads 设置并行GC，G1垃圾收集的线程数N，当机器的核数大于等于8时，垃圾收集使用的线程数为5/8 * N，小于8则用N&lt;/p&gt;

&lt;p&gt;-XX:CMSInitiatingOccupancyFraction 触发CMS主要收集的内存占用率&lt;br /&gt;
-XX:UseGCOverheadLimit  屏蔽CMS产生OOME&lt;/p&gt;

&lt;p&gt;-XX:MaxGCPauseMillis 设置并行GC，G1的最大停顿时长&lt;br /&gt;
-XX:InitiatingHeapOccupancyPercent 触发G1主要收集的内存占用率&lt;br /&gt;
-XX:G1HeapRegionSize G1的区块大小&lt;br /&gt;
-XX:G1NewSizePercent G1最小新生代大小&lt;br /&gt;
-XX:G1MaxNewSizePercent G1最大新生代大小  &lt;br /&gt;
-XX:ConcGCThreads  设置G1的并行标记线程数&lt;br /&gt;
-XX:G1MixedGCLiveThresholdPercent 设置G1一个老年代区块被加入混合回收所需要的满载率&lt;br /&gt;
-XX:G1HeapWastePercent 设置触发G1进行混合收集的浪费率，当垃圾对象在堆里占比不足浪费率不会触发混合收集&lt;br /&gt;
-XX:G1MixedGCCountTarget G1进行混合收集时进行混合收集的次数&lt;br /&gt;
-XX:G1OldCSetRegionThresholdPercent G1一次混合收集中老年代区块数占收集区块的数上限&lt;br /&gt;
-XX:G1ReservePercent G1预留给拷贝阶段使用的空间&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/&quot;&gt;Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;《Java性能优化权威指南》&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Jan 2017 10:00:00 +0800</pubDate>
        <link>/2017/01/04/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97_JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%85%A5%E9%97%A8/</link>
        <guid isPermaLink="true">/2017/01/04/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97_JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%85%A5%E9%97%A8/</guid>
        
        <category>JVM</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>JVM性能监控简介</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#jvm&quot; id=&quot;markdown-toc-jvm&quot;&gt;监控JVM垃圾回收&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jit&quot; id=&quot;markdown-toc-jit&quot;&gt;监控JIT编译&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;监控类加载&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;监控Java应用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对JVM性能监控的基本知识的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;JVM的性能监控主要包括3种监控：垃圾回收、JIT编译 和 类加载&lt;/p&gt;

&lt;h2 id=&quot;jvm&quot;&gt;监控JVM垃圾回收&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;命令行工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过用命令行参数来打印出垃圾回收的一些信息，通过这些信息来监控垃圾回收&lt;/p&gt;

&lt;p&gt;获取垃圾收集信息的相关命令：&lt;br /&gt;
-verbose:gc 输出垃圾收集信息&lt;br /&gt;
-XX:+PrintGCDetails 输出GC详细信息&lt;br /&gt;
-XX:+PrintGCTimeStamps 输出时间戳&lt;br /&gt;
-XX:+PrintGCDateStamps 输出日期&lt;br /&gt;
-Xloggc:&lt;filename&gt; 输出到文件  
-XX:+PrintGCApplicationConcurrentTIme 报告application在安全点之间的运行时间  
+XX:+PrintGCApplicationStoppedTime 报告application线程被阻塞的时间&lt;/filename&gt;&lt;/p&gt;

&lt;p&gt;从垃圾收集输出的日志里需要获得信息包括：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;所使用的垃圾收集器&lt;/li&gt;
  &lt;li&gt;Java堆大小&lt;/li&gt;
  &lt;li&gt;新生代和老年代大小&lt;/li&gt;
  &lt;li&gt;永久代大小&lt;/li&gt;
  &lt;li&gt;Minor GC持续时间&lt;/li&gt;
  &lt;li&gt;Minor GC的频率&lt;/li&gt;
  &lt;li&gt;Minor GC的空间回收量&lt;/li&gt;
  &lt;li&gt;Major GC的持续时间&lt;/li&gt;
  &lt;li&gt;Major GC的频率&lt;/li&gt;
  &lt;li&gt;每个并发回收周期内的空间回收量&lt;/li&gt;
  &lt;li&gt;垃圾回收前后Java堆的占用量&lt;/li&gt;
  &lt;li&gt;垃圾回收前后新生代和老年代的占用量&lt;/li&gt;
  &lt;li&gt;垃圾回收前后永久代的占用量&lt;/li&gt;
  &lt;li&gt;是否老年代或永久代的占用触发Major GC&lt;/li&gt;
  &lt;li&gt;应用是否显式触发垃圾回收&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对收集到的垃圾收集信息可以用GCHisto来进行离线分析&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图形化工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JConsole，VisualGC和VisualVM&lt;/p&gt;

&lt;h2 id=&quot;jit&quot;&gt;监控JIT编译&lt;/h2&gt;

&lt;p&gt;JIT编译器会对运行次数足够多的代码进行优化，对于优化不当的代码会进行逆优化甚至重新优化&lt;/p&gt;

&lt;p&gt;当需要监控优化，逆优化和重新优化的信息时可用命令行参数&lt;br /&gt;
-XX:+PrintCompilation&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;监控类加载&lt;/h2&gt;

&lt;p&gt;当类加载到足够多的时候会触发垃圾回收，通过监控类加载信息能为优化提供信息&lt;/p&gt;

&lt;p&gt;可以使用图形化工具来查看类的加载量：JConsole，VisualGC和VisualVM&lt;/p&gt;

&lt;p&gt;可通过垃圾回收的日志信息来查看类的卸载&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;监控Java应用&lt;/h2&gt;

&lt;p&gt;监控应用的常用方法是查看应用的输出日志&lt;br /&gt;
当应用使用了内置的MBean时，可以使用兼容的JMX工具来监控这些MBean&lt;/p&gt;

&lt;p&gt;若要快速地定位应用的锁竞争信息，可以通过命令工具jstack来获取线程的转储信息&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;《Java性能优化权威指南》&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Jan 2017 10:00:00 +0800</pubDate>
        <link>/2017/01/04/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97_JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</link>
        <guid isPermaLink="true">/2017/01/04/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97_JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</guid>
        
        <category>性能监控</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java语言多线程简介</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;Java基本的多线程应用&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;封装任务&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;创建和管理线程&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;配置线程&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;线程的互斥&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;线程的协作&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;线程的死锁&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;任务的终结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java语言多线程的基本知识的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;多线程主要有两个好处：更快的解决问题，能给某些应用场景提供更好的设计&lt;/p&gt;

&lt;p&gt;以下内容中的代码均出自《Java编程思想》&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;Java基本的多线程应用&lt;/h2&gt;

&lt;p&gt;在Java的多线程应用中，设计到几个基本的概念需要首先了解&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任务：任务是每个线程中所执行的逻辑，想并发执行的任务会在不同的线程上执行&lt;/li&gt;
  &lt;li&gt;线程：线程是用来驱动任务并发执行的资源，每个任务会绑定到一个线程上&lt;/li&gt;
  &lt;li&gt;线程池：管理多个线程的生命周期工具，例如像重用线程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java提供了一些基本的API来使用多线程编程，这些基本API包括&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;封装任务，每个任务都单独运行在一个线程上&lt;/li&gt;
  &lt;li&gt;创建和管理线程&lt;/li&gt;
  &lt;li&gt;对线程进行配置，如优先级，deamon等属性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;封装任务&lt;/h3&gt;

&lt;p&gt;当使用线程时，其实是想在不同的线程上执行不同的任务，所以需要先创建任务，创建任务可以使用两种接口：Runnable和Callable&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class LiftOff implements Runnable {
	public void run() {
		// Do things 
	}
}

class TaskWithResult implements Callable&amp;lt;String&amp;gt; {
	public String call() {
		// Do things
		return &quot;&quot;;
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可见，区别就是Callable的接口有返回值，也就是线程执行完以后能返回结果&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;创建和管理线程&lt;/h3&gt;

&lt;p&gt;所有的任务都需要线程来驱动，然后不同的任务就可以在不同的线程驱动下并发的运行了&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class BasicThreads {
	public static void main(String[] args) {
		Thread t = new Thread(new Runnable(){
			public void run() {
				// Do things 
			}
		});
		t.start();
		Print.print(&quot;Waiting for Lift off&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;直接创建一个Thread，然后把Runnable放到构造函数里，然后start，就能运行任务了,但Thread是不能用来驱动Callable的，下面会展示驱动Callable的方法&lt;/p&gt;

&lt;p&gt;通过手动创建的Thread需要自己管理Thread，例如考虑到Thread资源的重用等问题，这些逻辑会比较复杂，为此，新的Java API提供了多种线程池，这些管理器提供的功能主要是创建线程，管理线程生命周期等，它们都实现了ExecutorService接口，以下可以创建线程池&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Executors.newFixedThreadPool：创建线程数量固定的线程池&lt;/li&gt;
  &lt;li&gt;Executors.newCachedThreadPool；创建线程池，线程数目不定，按需创建&lt;/li&gt;
  &lt;li&gt;Executors.newSingleThreadExecutor：创建只有一个线程的线程池,所有提交的任务变成序列执行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过线程池可以驱动Runnable和Callable&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class CachedThreadPool {
	public static void main(String[] args) {
		ExecutorService exec = Executors.newCachedThreadPool();
		for (int i = 0; i &amp;lt; 5; i++) {
			exec.execute(new Runnable(){
				public void run() {
					// Do things 
				}
			});
		}
		exec.shutdown();
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class CallableDemo {
	public static void main(String[] args) {
		List&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt; results = new ArrayList&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt;();
		ExecutorService exec = Executors.newCachedThreadPool();
		for (int i = 0; i &amp;lt; 5; i++) {
			results.add(exec.submit(new Callable&amp;lt;String&amp;gt;(){
				public String run() {
					// Do things 
					return &quot;&quot;;
				}
			}));
		}
		for (Future&amp;lt;String&amp;gt; f : results) {
			try {
				Print.print(f.get());
			} catch (InterruptedException e) {
				e.printStackTrace();
			} catch (ExecutionException e) {
				e.printStackTrace();
			} finally {
				exec.shutdown();
			}
		}
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当用线程池驱动Callable时，通过Future来获得返回结果&lt;br /&gt;
现在一般都是用线程池来提交任务，管理线程的生命周期&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;配置线程&lt;/h3&gt;

&lt;p&gt;可以通过Thread的API来配置线程的一些属性，例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Thread.currentThread().setName //设置线程名字
Thread.currentThread().setDaemon //设置线程是否为后台线程
Thread.currentThread().setPriority //设置线程优先级
Thread.currentThread().setUncaughtExceptionHandler //设置线程的异常处理器

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当使用线程池来创建线程时，需要给线程池提供一个线程Factory，在这个Factory中创建线程并配置线程的属性，例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
	public void uncaughtException(Thread t, Throwable e) {
		Print.print(&quot;caught &quot; + e);
	}
}

public class MyThreadFactory implements ThreadFactory {
	public Thread newThread(Runnable r) {
		Thread t = new Thread(r);
		t.setDaemon(true);
		t.setPriority(Thread.MIN_PRIORITY);
		t.setName(&quot;Test&quot;);
		t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
		return t;
	}
}

class DaemonFromFactory implements Runnable {
	public void run() {
		// Do things
	}
	public static void main(String[] args) throws InterruptedException {
		ExecutorService exec = Executors
				.newCachedThreadPool(new MyThreadFactory());
		for (int i = 0; i &amp;lt; 10; i++) {
			exec.execute(new DaemonFromFactory());
		}
		Print.print(&quot;All daemons started&quot;);
		TimeUnit.MILLISECONDS.sleep(500);
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上代码创建了一个异常处理器MyUncaughtExceptionHandler，然后创建一个线程工厂，在线程工厂里创建线程并配置线程参数，这些线程都是驱动任务的线程&lt;/p&gt;

&lt;p&gt;以上都是在使用多线程时用到的概念：任务，线程，线程池和它们用法的简单例子，对于这几个概念所对应的类和接口，Java提供了很多API，希望使用之前先多看看代码例子熟悉API&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;线程的互斥&lt;/h2&gt;

&lt;p&gt;多线程的复杂在于不同的线程之间会互相影响，其中一种是不同的线程会共用资源，内存，I/O等；这些资源有时候是只能由一个线程从任务的开始到结束的过程中来独占的，不然在线程任务的中间被其他线程干扰后导致状态改变会引起问题&lt;br /&gt;
所以，多线程需要解决的一个重要问题是资源的互斥使用，这个问题其实可表现为两方面：原子性和可见性&lt;/p&gt;

&lt;p&gt;原子性：一系列操作从开始到结束不能被分割，中断；例如i++其实中间包括好几条指令，这些指令执行时不能被分割中断&lt;/p&gt;

&lt;p&gt;可见性：在不同的线程之间，一个线程经过处理得到的结果时，其他线程读取这个结果时，能得到这个结果；例如一个线程执行了i++，然后其他线程读取i时能取得i自增以后的结果&lt;/p&gt;

&lt;p&gt;对除long和double外的基本类型进行读取和赋值时，这两个操作是原子的，但不能确保可见性；当用volatile修饰变量时，对变量进行读取和赋值的操作符合原子性和可见性&lt;/p&gt;

&lt;p&gt;volatile只能保证变量的读取和赋值满足原子性和可见性，甚至对于基本类型的变量的加减等操作是不能保证的，这时可以用Java API中的原子类，它们提供一些基本类型的运算操作，这些操作是原子的和可见的&lt;/p&gt;

&lt;p&gt;但为了保证事务(一系列操作)的原子性和可见性，则需要通过锁来完成，使用锁的方法包括synchronized，Lock&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;如何满足原子性&lt;/th&gt;
      &lt;th&gt;如何满足可见性&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;除long和double外的基本类型的取值和赋值&lt;/td&gt;
      &lt;td&gt;自动满足&lt;/td&gt;
      &lt;td&gt;用volatile修饰&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;变量的取值和赋值&lt;/td&gt;
      &lt;td&gt;用volatile修饰&lt;/td&gt;
      &lt;td&gt;用volatile修饰&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;一系列操作&lt;/td&gt;
      &lt;td&gt;用锁&lt;/td&gt;
      &lt;td&gt;用锁&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;除了确保线程之间的互斥来解决冲突以外，其实有时可以避免冲突，例如用ThreadLocal火其他方法来使得线程不共享资源&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;线程的协作&lt;/h2&gt;

&lt;p&gt;除了保持线程对资源的互斥使用外，还需要解决线程间的协作问题，也就是一个线程需的输入时另一个线程产生的输出，为了保证这两线程任务的顺序性和资源的互斥使用，Java API在锁之上提供了握手API：wait，notify，notifyAll&lt;/p&gt;

&lt;p&gt;wait：一个下游线程在获得一个资源的锁，单独使用资源的时候，发现其上游线程还没处理好时，释放获得的资源的锁，并阻塞自己
notify，notifyAll：一个上游线程在获得一个资源的锁后，处理完以后，释放获得的锁并通知下游线程&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Car {
	private boolean waxOn = false;

	public synchronized void wax() throws InterruptedException {
		while (waxOn) {
			wait();
		}
		waxOn = true;
		Print.printnb(&quot;Wax on! &quot;);
		notifyAll();
	}

	public synchronized void buffer() throws InterruptedException {
		while (!waxOn) {
			wait();
		}
		waxOn = false;
		Print.print(&quot;Wax off! &quot;);
		notifyAll();
	}

}

class WaxOn implements Runnable {
	private Car car;

	public WaxOn(Car car) {
		this.car = car;
	}

	public void run() {
		try {
			while (!Thread.interrupted()) {
				car.wax();
				TimeUnit.MILLISECONDS.sleep(200);
			}
		} catch (InterruptedException e) {
			Print.print(&quot;Existing via interrupt&quot;);
		}
		Print.print(&quot;Ending wax on task&quot;);
	}

}

class WaxOff implements Runnable {
	private Car car;

	public WaxOff(Car car) {
		this.car = car;
	}

	public void run() {
		try {
			while (!Thread.interrupted()) {
				car.buffer();
				TimeUnit.MILLISECONDS.sleep(200);
			}
		} catch (InterruptedException e) {
			Print.print(&quot;Existing via interrupt&quot;);
		}
		Print.print(&quot;Ending wax off task&quot;);
	}
}

public class WaxMatic {

	public static void main(String[] args) throws InterruptedException {
		ExecutorService exec = Executors.newCachedThreadPool();
		Car car = new Car();
		exec.execute(new WaxOn(car));
		exec.execute(new WaxOff(car));
		TimeUnit.SECONDS.sleep(5);
		exec.shutdownNow();
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一个值得的注意的地方是wait，notify等API都是在锁对象执行的，所以必须要先通过sychronized获得同一个对象的锁，然后才能使用握手API&lt;/p&gt;

&lt;p&gt;另外Lock也提供了握手的接口，要通过Lock获得Condition对象，然后使用Condition对象完成握手&lt;br /&gt;
condition.await&lt;br /&gt;
condition.signal&lt;br /&gt;
condition.signalAll&lt;/p&gt;

&lt;p&gt;握手API是非常底层的线程协作API，Java API提供了一些高层的组件，这些组件的操作自动完成了握手的功能，例如BlockingQueue等，它们都更方便的使用&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;线程的死锁&lt;/h2&gt;

&lt;p&gt;当多线程满足以下4个条件时能出现死锁：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;存在互斥使用的资源&lt;/li&gt;
  &lt;li&gt;至少一个任务持有一个资源并等待另外一个资源&lt;/li&gt;
  &lt;li&gt;非抢占式的使用资源&lt;/li&gt;
  &lt;li&gt;循环等待&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了防止死锁，只需要破坏以上其中一个条件即可&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;任务的终结&lt;/h2&gt;

&lt;p&gt;当任务被终结时，线程会被回收&lt;br /&gt;
终结任务的方式就是通过标记位来通知任务需要终结自己&lt;/p&gt;

&lt;p&gt;但任务在其执行过程中使用一些操作会被阻塞时，如何终结会阻塞的任务就变得稍微复杂&lt;br /&gt;
一个任务进入阻塞状态的原因包括&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sleep&lt;/li&gt;
  &lt;li&gt;I/O操作&lt;/li&gt;
  &lt;li&gt;wait&lt;/li&gt;
  &lt;li&gt;尝试获取锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了终结可能进入阻塞的任务，则需要中断阻塞才行，可惜不是每种阻塞都能被中断&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;终结sleep，wait阻塞&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过Thread.interrupt，Future.cancel，ExecutorService.shutdownNow等来终端线程的sleep和wait，对于这种中断处理需要按照一种模式来安全地编码，释放资源&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class NeedsCleanup {
	private final int id;

	public NeedsCleanup(int id) {
		this.id = id;
	}

	public void cleanup() {
		Print.print(&quot;Cleaning up &quot; + id);
	}
}

class Blocked3 implements Runnable {
	private volatile double d = 0.0;

	public void run() {
		try {
			while (!Thread.interrupted()) {
				NeedsCleanup n1 = new NeedsCleanup(1);
				try {
					Print.print(&quot;Sleeping&quot;);
					TimeUnit.SECONDS.sleep(1);

					NeedsCleanup n2 = new NeedsCleanup(2);
					try {
						Print.print(&quot;Calculating&quot;);
						for (int i = 0; i &amp;lt; 2500000; i++) {
							d = d + (Math.PI + Math.E) / d;
						}
						Print.print(&quot;Finish time-consuming operation.&quot;);
					} finally {
						n2.cleanup();
					}
				} finally {
					n1.cleanup();
				}
			}
			Print.print(&quot;Existing via while() test&quot;);
		} catch (InterruptedException e) {
			Print.print(&quot;Existing via InterruptedException&quot;);
		}
	}

}

public class InterruptingIdiom {

	public static void main(String[] args) throws InterruptedException {
		if (args.length != 1) {
			Print.print(&quot;usage: java InterruptingIdiom delay-in-mS&quot;);
			System.exit(1);
		}
		Thread t = new Thread(new Blocked3());
		t.start();
		TimeUnit.MILLISECONDS.sleep(new Integer(args[0]));
		t.interrupt();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在任务中使用嵌套的try catch来完成资源的释放，通过while条件判断来获取中断的信号&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;终结I/O阻塞&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不能通过线程API来中断I/O，但可以通过释放stream等资源来跳出阻塞&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class IOBlocked implements Runnable {
	private InputStream in;

	public IOBlocked(InputStream is) {
		in = is;
	}

	public void run() {
		try {
			Print.print(&quot;Waiting for read()%: &quot;);
			in.read();
		} catch (IOException e) {
			if (Thread.currentThread().isInterrupted()) {
				Print.print(&quot;Interrupted from blocked I/O&quot;);
			} else {
				throw new RuntimeException(e);
			}
		}
		Print.print(&quot;Exiting IOBlocked.run()&quot;);
	}
}

public class CloseResource {
	public static void main(String[] args) throws Exception {
		ExecutorService exec = Executors.newCachedThreadPool();
		InputStream socketInput = new Socket(&quot;localhost&quot;, 8080)
				.getInputStream();
		exec.execute(new IOBlocked(socketInput));
		exec.execute(new IOBlocked(System.in));
		TimeUnit.MILLISECONDS.sleep(100);
		Print.print(&quot;Shutting down all threads&quot;);
		exec.shutdownNow();
		TimeUnit.SECONDS.sleep(1);
		Print.print(&quot;Closing &quot; + socketInput.getClass().getName());
		socketInput.close(); // Releases blocked thread
		TimeUnit.SECONDS.sleep(1);
		Print.print(&quot;C1osing &quot; + System.in.getClass().getName());
		System.in.close(); // Releases blocked thread
		TimeUnit.SECONDS.sleep(1);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;若使用nio中的I/O API，则有API来中断I/O阻塞&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class NIOBlocked implements Runnable {
	private final SocketChannel sc;

	public NIOBlocked(SocketChannel sc) {
		this.sc = sc;
	}

	public void run() {
		try {
			Print.print(&quot;Waiting for read() in &quot; + this);
			sc.read(ByteBuffer.allocate(1));
		} catch (ClosedByInterruptException e) {
			Print.print(&quot;ClosedBy1nterruptException&quot;);
		} catch (AsynchronousCloseException e) {
			Print.print(&quot;AsynchronousCloseException&quot;);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		Print.print(&quot;Exiting NIOBlocked.run() &quot; + this);
	}
}

public class NIOInterruption {

	public static void main(String[] args) throws Exception {
		ExecutorService exec = Executors.newCachedThreadPool();
		InetSocketAddress isa = new InetSocketAddress(&quot;localhost&quot;, 8080);
		SocketChannel sc1 = SocketChannel.open(isa);
		SocketChannel sc2 = SocketChannel.open(isa);
		Future&amp;lt;?&amp;gt; f = exec.submit(new NIOBlocked(sc1));
		exec.execute(new NIOBlocked(sc2));
		// or can interrupt all by exec.shutdownNow();
		exec.shutdown();
		TimeUnit.SECONDS.sleep(1);
		// Produce an interrupt via cancel:
		f.cancel(true);
		TimeUnit.SECONDS.sleep(1);
		// Release the block by closing the channel:
		sc2.close();
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;终结锁阻塞&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果进入阻塞时是通过Lock的lockInterruptibly API来获取锁的，则阻塞可以被中断&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BlockedMutex {
	private Lock lock = new ReentrantLock();

	public BlockedMutex() {
		// Acquire it right away. to demonstrate interruption
		// of a task blocked on a ReentrantLock:
		lock.lock();
	}

	public void f() {
		try {
			// This will never be available to a second task
			lock.lockInterruptibly(); // Special call
			Print.print(&quot;lock acquired in f()&quot;);
		} catch (InterruptedException e) {
			Print.print(&quot;1nterrupted from lock acquisition in f()&quot;);
		}
	}
}

class Blocked2 implements Runnable {
	BlockedMutex blocked = new BlockedMutex();

	public void run() {
		Print.print(&quot;Waiting for f() i n BlockedMutex&quot;);
		blocked.f();
		Print.print(&quot;Broken out of blocked call &quot;);
	}
}

public class Interrupting2 {

	public static void main(String[] args) throws InterruptedException {
		Thread t = new Thread(new Blocked2());
		t.start();
		TimeUnit.SECONDS.sleep(1);
		Print.print(&quot;Issuing t.interrupt()&quot;);
		t.interrupt();
	}

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 04 Jan 2017 10:00:00 +0800</pubDate>
        <link>/2017/01/04/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B1%87%E6%80%BB/</link>
        <guid isPermaLink="true">/2017/01/04/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B1%87%E6%80%BB/</guid>
        
        <category>Multi-thread</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>JVM垃圾收集器简介</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#gc&quot; id=&quot;markdown-toc-gc&quot;&gt;GC进行内存回收的普遍方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gc--&quot; id=&quot;markdown-toc-gc--&quot;&gt;GC进行 次要收集 的方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gc-1&quot; id=&quot;markdown-toc-gc-1&quot;&gt;序列化GC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gc-gc&quot; id=&quot;markdown-toc-gc-gc&quot;&gt;并行GC(又名 吞吐率GC)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gcthe-mostly-concurrent-collectors&quot; id=&quot;markdown-toc-gcthe-mostly-concurrent-collectors&quot;&gt;并发GC(The Mostly Concurrent Collectors)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gccms&quot; id=&quot;markdown-toc-gccms&quot;&gt;并发标记清除GC(CMS)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gcg1&quot; id=&quot;markdown-toc-gcg1&quot;&gt;垃圾优先GC(G1)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对JVM垃圾收集器的基本知识的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;垃圾收集器(garbage collector (GC)) 是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GC其实是一种自动的内存管理工具，其行为主要包括2步&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在Java堆中，为新创建的对象分配空间&lt;/li&gt;
  &lt;li&gt;在Java堆中，回收没用的对象占用的空间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;为什么需要GC？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;释放开发人员的生产力&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么需要多种GC？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，Java平台被部署在各种各样的硬件资源上，其次，在Java平台上部署和运行着各种各样的应用，并且用户对不同的应用的 &lt;em&gt;性能指标&lt;/em&gt; (吞吐率和延迟) 预期也不同，为了满足不同应用的对内存管理的不同需求，JVM提供了多种GC以供选择&lt;/p&gt;

&lt;p&gt;&lt;em&gt;性能指标&lt;/em&gt;&lt;br /&gt;
最大停顿时长：垃圾回收导致的应用停顿时间的最大值&lt;br /&gt;
吞吐率：垃圾回收停顿时长和应用运行总时长的比例&lt;/p&gt;

&lt;p&gt;不同的GC能满足不同应用不同的性能需求，现有的GC包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;序列化GC(serial garbage collector)：适合占用内存少的应用&lt;/li&gt;
  &lt;li&gt;并行GC 或 吞吐率GC(parallel or throughput garbage collector)：适合占用内存较多，多CPU，追求高吞吐率的应用&lt;/li&gt;
  &lt;li&gt;并发GC：适合占用内存较多，多CPU的应用，对延迟有要求的应用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gc&quot;&gt;GC进行内存回收的普遍方法&lt;/h2&gt;

&lt;p&gt;垃圾收集必须要完成两件事：&lt;em&gt;垃圾对象的检测&lt;/em&gt; 和 &lt;em&gt;内存空间回收&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;垃圾对象的检测&lt;/em&gt; 有两种方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;引用计数：每个对象都有个引用计数器，当引用数为0时成为垃圾，缺点是无法检测循环引用&lt;/li&gt;
  &lt;li&gt;跟踪：从根对象开始遍历可达的对象图，不可达的都是垃圾&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于循环引用的问题，一般采用跟踪方法&lt;/p&gt;

&lt;p&gt;&lt;em&gt;内存空间回收&lt;/em&gt; 有两种方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;压缩收集：在一个内存块内通过把存活对象移动到堆的一端，剩余空间即为回收的空间，这样可以消除碎片&lt;/li&gt;
  &lt;li&gt;拷贝收集：把内存分成多块，通过把存活对象拷贝到一个新的区域，然后回收旧的区域，好处是垃圾对象的检测和收集同时进行，但需要更大的空间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不同的垃圾收集算法就是在基本的 跟踪方法 和 &lt;em&gt;内存空间回收&lt;/em&gt; 方法之上加入额外的机制来提高回收的效率&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提高回收效率的机制：分代&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过对大量应用的检测，可以发现应用中的对象生命周期符合一个规律：大量对象都会在创建以后不久就会死亡，只有少量对象存活的时间比较长&lt;br /&gt;
所以可以把内存分成两块进行管理，一块内存(新生代)用来存放创建不久的对象，一块内存(老年代)用来存放存活时间比较长的对象，当某一块足够满就收集那一块内存，这样老年代内存就可以很久才收集一次，减少每次内存收集所需要的 检测对象数目和内存回收大小，提高效率&lt;br /&gt;
新生代里的对象大多是创建不久就死的对象，回收时涉及少量存活对象所以回收的效率特别高，新生代的回收叫 次要收集(minor collection)
老年代里的对象大多是存活很久的对象，回收时涉及大量存活对象所以回收相对慢，老年代的回收叫 主要收集(major collection)，为了减少回收次数，一般老年代空间比较大&lt;/p&gt;

&lt;p&gt;所有的Java GC都会把Java堆进行分代回收，所以可以简单地说垃圾收集分为3个步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在新生代，给新创建的对象分配空间；把新生代中存活时间足够长的对象移动到老年代&lt;/li&gt;
  &lt;li&gt;当整个Java堆的占用量达到阈值时，在老年代触发 寻找存活的对象的活动，对存活的对象进行标记&lt;/li&gt;
  &lt;li&gt;把存活对象统一拷贝到某块内存区域，然后回收原来的内存区域&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;提高回收效率的机制：自适应&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于应用在运行过程中，在不同的阶段会对内存有不同的需求，GC通过自动的调整来增加或减少内存回收所使用的资源&lt;/p&gt;

&lt;h2 id=&quot;gc--&quot;&gt;GC进行 次要收集 的方法&lt;/h2&gt;

&lt;p&gt;Java的分代GC的 &lt;em&gt;次要收集&lt;/em&gt; 方法逻辑上都相同，所以此处描述的次要收集方法对所有GC适用&lt;/p&gt;

&lt;p&gt;新生代逻辑上划分为 一个Eden区和一对Survivor区&lt;br /&gt;
两个Survivor不会同时用来存放对象，每次都会有一个存放对象，另一个为空；所有新创建的对象都在Eden上分配内存，当Eden占用足够满就进行次要收集；收集时先用 &lt;em&gt;跟踪&lt;/em&gt; 方法在Eden和一个Survior钟找出来所有存活对象，然后把存活对象(不够久)拷贝到空着的Survivor中，然后清空Eden和原来的Survivor；原Survivor中某些对象存活时间足够长时会拷贝到老年代&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一些小细节&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Eden分配对象空间时使用 &lt;em&gt;指针碰撞法&lt;/em&gt; ，一个指针指向Eden的启示位置，分配空间是直接在指针出分配，然后滑动指针到新地址，新旧地址差为分配的空间大小&lt;/p&gt;

&lt;p&gt;新创建的对象比Eden容量还大时，直接在老年代给对象分配空间&lt;/p&gt;

&lt;p&gt;Survivor中没有足够空间存放存活对象时，存活时间不够长的对象会被拷贝到老年代，容易导致 主要收集&lt;/p&gt;

&lt;h2 id=&quot;gc-1&quot;&gt;序列化GC&lt;/h2&gt;

&lt;p&gt;序列化GC在进行垃圾回收时会把所有的线程都停掉(Stop the world (STW))，并且用单线程的方式来进行回收，因此它适合单CPU，内存需求不高的应用；对于这类应用，它效率很高&lt;/p&gt;

&lt;p&gt;序列化GC使用的次要收集方法如上所述&lt;/p&gt;

&lt;p&gt;序列化GC使用的主要收集方法也很简单，当内存占用达到阈值时触发主要收集；首先通过 &lt;em&gt;跟踪&lt;/em&gt; 找到所有存活的对象，然后通过 &lt;em&gt;压缩收集&lt;/em&gt; 方法来回收老年代空间&lt;/p&gt;

&lt;h2 id=&quot;gc-gc&quot;&gt;并行GC(又名 吞吐率GC)&lt;/h2&gt;

&lt;p&gt;并行GC和序列化GC在 次要收集 和 主要收集 使用一样的方法，都会让应用程序停止，不同的是并行GC使用多线程同时进行内存回收来减少停顿时间，获取高吞吐率&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一些小细节&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每个线程都会在老年代预留一个缓冲来存放从Servivor拷贝的对象，这样容易产生碎片，增大主要收集的频率&lt;/p&gt;

&lt;p&gt;当98%的时间用在垃圾回收而只有不到2%的空间得到回收，就会抛出OutOfMemoryException(OOME)&lt;/p&gt;

&lt;h2 id=&quot;gcthe-mostly-concurrent-collectors&quot;&gt;并发GC(The Mostly Concurrent Collectors)&lt;/h2&gt;

&lt;p&gt;并发GC通过使用特别的 &lt;em&gt;主要收集&lt;/em&gt; 算法来使得在主要收集时，大部分的回收工作能和应用程序并发进行来减少应用的停顿时间，但这样会需要更长的主要收集阶段，并一直占用这线程资源，这样导致了吞吐率下降&lt;/p&gt;

&lt;p&gt;并发GC适合在多核，中到大规模数据量，对延迟有一定要求的应用中使用&lt;/p&gt;

&lt;p&gt;Hostpot JVM有两个并发GC：并发标记清除GC(Concurrent Mark Sweep (CMS) Collector) 和 垃圾优先GC(Garbage-First Garbage Collector (G1))&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一些小细节&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于并发GC在&lt;em&gt;主要收集&lt;/em&gt;过程中使用跟踪方法来找到所有存活对象，但跟踪的过程是和应用程序并发执行的，所以跟踪方法只能保证找到所有存活的对象，但不能保证剔除掉应用在跟踪过程中不再使用的垃圾对象，所以并发GC每次垃圾回收都不能把所有的垃圾对象收集完，这些存活的垃圾对象叫&lt;em&gt;浮动垃圾&lt;/em&gt;，它们都会在下一次&lt;em&gt;主要收集&lt;/em&gt;时被清除&lt;/p&gt;

&lt;p&gt;并发GC的&lt;em&gt;主要收集&lt;/em&gt;和应用并发执行，&lt;em&gt;主要收集&lt;/em&gt;期间应用也一直在Eden上创建新对象，也会触发&lt;em&gt;次要收集&lt;/em&gt;，所以&lt;em&gt;主要收集&lt;/em&gt;过程中的一些并发执行阶段会被&lt;em&gt;次要收集&lt;/em&gt;打断，所以整个&lt;em&gt;主要收集&lt;/em&gt;过程会包含一些&lt;em&gt;次要收集&lt;/em&gt;，并且&lt;em&gt;次要收集&lt;/em&gt;也会向老年代拷贝对象&lt;/p&gt;

&lt;p&gt;和并行GC一样，当98%的时间用在垃圾回收而只有不到2%的空间得到回收，就会抛出OOOME&lt;/p&gt;

&lt;h2 id=&quot;gccms&quot;&gt;并发标记清除GC(CMS)&lt;/h2&gt;

&lt;p&gt;CMS在进行主要收集时，某些步骤中和应用并发执行，减少应用的停顿时长，适合在多核，中到大规模数据量，对延迟有一定要求的应用中使用&lt;/p&gt;

&lt;p&gt;CMS的次要收集过程和并行GC一样&lt;/p&gt;

&lt;p&gt;CMS的主要收集过程包括一系列阶段：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始标记阶段：停掉所有应用线程(STW)，从根源(Java栈，寄存器等)和Java堆的其他地方(例如新生代)来标记出所有存活的对象，然后恢复所有应用线程&lt;/li&gt;
  &lt;li&gt;并发标记阶段：从上一阶段标记出来的存活对象开始跟踪找到那些可达的存活对象并标记，这个阶段是跟应用并发执行的&lt;/li&gt;
  &lt;li&gt;并发重标记阶段：在上阶段应用可能会修改那些已经被跟踪过的对象，这些对象可能会引用一些新存活的对象，这时候需要重新跟踪一遍这些更新过的对象；这是一个可选的优化阶段，用来减少重新标记所停顿的时间&lt;/li&gt;
  &lt;li&gt;重标记阶段：停掉所有应用线程(STW)，重新跟踪一遍根源和被修改过的已跟踪对象，然后恢复所有应用线程&lt;/li&gt;
  &lt;li&gt;并发清除阶段：并发的把内存回收，回收的内存放到一个空闲列表里&lt;/li&gt;
  &lt;li&gt;准备阶段：并发的调整堆和为下一次&lt;em&gt;主要收集&lt;/em&gt;准备各种数据结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;一些小细节&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有两种机制能触发&lt;em&gt;主要收集&lt;/em&gt;&lt;br /&gt;
一种机制是,CMS会维持着两个估计的时长：还有多久老年代会满，进行一次主要收集需要多久，当进行主要收集的时长小于老年代满掉的时长就会进行&lt;em&gt;主要收集&lt;/em&gt;
另外一个机制是CMS有个配置是老年代的占用阈值，当老年代的占用率达到阈值则进行&lt;em&gt;主要收集&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;主要收集&lt;/em&gt;期间会有多次&lt;em&gt;次要收集&lt;/em&gt;，为了防止&lt;em&gt;重标记&lt;/em&gt;的停顿和&lt;em&gt;次要收集&lt;/em&gt;的停顿连起来造成比较长的停顿，CMS会故意把&lt;em&gt;重标记&lt;/em&gt;安排在上一次&lt;em&gt;次要收集&lt;/em&gt;和下一次&lt;em&gt;次要收集&lt;/em&gt;的中间&lt;/p&gt;

&lt;p&gt;在老年代中有个数据结构叫&lt;em&gt;卡表&lt;/em&gt;，用来标记老年代的对象是否更新了对其他对象的引用，这样不用扫描整个老年代就能找到所有更新过引用的对象&lt;/p&gt;

&lt;p&gt;&lt;em&gt;主要收集&lt;/em&gt;完以后，没有对老年代进行压缩，只是把空闲内存放到一个空闲表里，下次分配空间时直接从空闲表里取，这样会导致内存有碎片&lt;/p&gt;

&lt;p&gt;如果CMS在&lt;em&gt;主要收集&lt;/em&gt;完成，老年代空间已经用完，则会抛Concurrent Mode Failure(CMF)，引发一次STW的全收集，代价非常大，这意味着需要增大老年代的空间或增多&lt;em&gt;主要收集&lt;/em&gt;使用的线程数&lt;/p&gt;

&lt;p&gt;CMS有一个&lt;em&gt;渐进式模式&lt;/em&gt;，这个模式在JDK8时开始弃用，将来有可能会被去掉；这模式适合在1或2核的机器上&lt;/p&gt;

&lt;h2 id=&quot;gcg1&quot;&gt;垃圾优先GC(G1)&lt;/h2&gt;

&lt;p&gt;和CMS差不多，G1在主要收集的一些步骤和应用是并发的，所以减少应用的停顿时长，适合在多核，大规模数据量，对延迟和吞吐率都有一定要求的应用中使用；当应用有以下任何一种特性时非常适合用G1：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;存活的数据多于50%Java堆的占用率&lt;/li&gt;
  &lt;li&gt;对象的创建速率和存活率变动很大&lt;/li&gt;
  &lt;li&gt;应用不希望停顿时间长(长于0.5s甚至1s)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;G1通过几个特别的技术来达到高吞吐率和低停顿&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;G1按固定大小把内存划分为很多小区块(region)，这个堆大概有2000多块；在逻辑上，某些小区块构成Eden，某些构成Survivor，某些构成老年代，这些小区块物理上是不相连的，并且构成新生代和老年代的区块是可以动态改变的，所以Minor GC的时间是可控的&lt;br /&gt;
当堆的占用率达到一定比例后被触发进行Major GC回收时，G1会在整个堆并发的标记存活对象，所以应用在标记时大部分时间没有停顿&lt;br /&gt;
当标记完后，G1会根据标记结果找出那些存活对象少的那些区块，然后回收这些找到区块，这样就能回收更多的空间(G1名字的来源)，回收这些区块时会把部分区块放到一次新生代区块回收中进行，通过在多次新生代回收中来回收掉老年代的区块
回收空间时，通过把存活对象并行地拷贝到空闲这的区块来回收旧的区块，这样能减少停顿时间，提高吞吐率，并起到压缩内存的效果&lt;br /&gt;
回收空间后，根据最大停顿时长利用预测模型来确定新生代的区块数，使得下次的Minor GC或混合GC不会超过最大停顿时长&lt;/p&gt;

&lt;p&gt;通过以上这几个特别的设计，G1要比CMS能更好的控制停顿时间，并且不产生内存碎片，同时达到比较好的延迟和吞吐率&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Minor GC&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当Eden包含的区块被新创建的对象占满时触发次要收集，停顿应用线程，并行地跟踪新生代里存活的对象，并行地把存活对象拷贝到新的Survivor区块或老年代区块，当完成拷贝后，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Major GC&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当整个Java堆的占用率达到某个阈值时触发主要收集，其包括以下步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始标记阶段：G1标记出从根源可达的对象，这个阶段是附属于一次次要收集的最后阶段，所以是STW&lt;/li&gt;
  &lt;li&gt;根区域扫描阶段：G1从上一阶段在Survivor里的标记的存活对象开始跟踪所有可达的老年代对象，这是一个并发的过程，而且必须在进行下一次次要收集之前完成&lt;/li&gt;
  &lt;li&gt;并发扫描阶段：G1在整个堆上并发地跟踪所有存活对象，期间可以被次要收集打断&lt;/li&gt;
  &lt;li&gt;重标记阶段：G1并行地跟踪在上面阶段经过更新的存活对象，找到未被标记的存活的对象，这是一个STW的阶段&lt;/li&gt;
  &lt;li&gt;清除阶段：这个阶段有两个步骤，首先是STW，根据预测模型确定需要回收的区块，这些区块会跟新生代一块回收；然后是并发的清除一些要回收区块的数据机构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;一些小细节&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果G1在拷贝对象到空闲区块时已经没有空闲区块时则会抛Concurrent Mode Failure(CMF)，引发一次STW的全收集，代价非常大&lt;/p&gt;

&lt;p&gt;G1会在标记的开始时使用一个数据结构snapshot-at-the-beginning (SATB)，用它来记录所有存活的对象，包括那些开始标记阶段以后新创建的对象；重标记阶段就是用SATB来找出需要重新标记的对象；SATB是造成浮动垃圾的根源&lt;/p&gt;

&lt;p&gt;每个区块都有自己的卡表，这样在查找更新过引用的对象时直接扫描卡表就行了，不用扫描整个堆&lt;/p&gt;

&lt;p&gt;G1在主要收集对老年代区块进行回收时，会把老年代区块和次要收集需要回收的Eden和Survivor区块放到一起并行回收，这种收集叫混合收集(Mixed Garbage Collections)，由于一次可能收集不完需要收集的老年代区块，所以多次次要收集都会是混合收集；当所有需要收集的老年代区域收集完成后，就会切换为只收集Eden和Survivor区块&lt;/p&gt;

&lt;p&gt;任何比区块的一半要大的对象是大对象(Humongous Object)，这些对象直接在老年代里分配空间，老年代里专门有一块连续的区块组成的大对象区块，每个大对象区块只保存一个大对象；&lt;br /&gt;
在分配空间给大对象前，都会先检查是否达到主要收集的阈值，若是则先进行一次主要收集&lt;br /&gt;
大对象是在主要收集和全收集的最后被回收的&lt;br /&gt;
大对象是不会在主要收集中被拷贝的，只有在全收集时G1才压缩大对象区块&lt;br /&gt;
每个大对象区块之间很可能会有空隙，所以会产生碎片&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html&quot;&gt;Getting Started with the G1 Garbage Collector&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.drdobbs.com/jvm/g1-javas-garbage-first-garbage-collector/219401061?pgno=1&quot;&gt;Java’s Garbage First Garbage Collector&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Jan 2017 10:00:00 +0800</pubDate>
        <link>/2017/01/04/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B/</link>
        <guid isPermaLink="true">/2017/01/04/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B/</guid>
        
        <category>GC</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java对象的终结与可达性</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#finalize&quot; id=&quot;markdown-toc-finalize&quot;&gt;finalize方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;对象的可达性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java对象的终结与可达性的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;finalize&quot;&gt;finalize方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对象可以有一个finalize方法，当垃圾回收器检查到对象成为垃圾时 会调用这个对象的finalize方法；执行外finalize方法后，垃圾回收器需要重新扫描来查找垃圾对象，因为在finalize方法里对象有可能复活了(被其他存活对象引用 变成可达时)；但一个对象的finalize方法只会被执行一次，当对象复活后又变成垃圾时，垃圾收集器是不会再调用它的finalize方法的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么使用finalize？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般作为释放非内存资源的最后一道“保护栏”，以防止客户没有明确的释放资源时能有JVM帮忙释放&lt;br /&gt;
让JVM帮忙在回收内存的最后时刻释放非内存资源，这些资源必须是非关键、时间不敏感的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;finalize非常底层，依赖JVM的机制，很容易用错，用错时还会导致资源和内存的不及时释放；&lt;br /&gt;
一般不用finalize方法，因为它是由垃圾收集器调用的，而垃圾回收的时机是应用不能控制的，具有不确定性；&lt;br /&gt;
可以用WeakReference来作为替代方案，请参考&lt;a href=&quot;http://www.devx.com/Java/Article/30192&quot;&gt;文章&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;对象的可达性&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在垃圾收集器看来，堆中的对象有6中状态：可达，软可达，弱可达，影子可达，可复活，不可达&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可达：普通的引用指向的对象都是可达，垃圾收集器是不会回收 可达对象的&lt;/li&gt;
  &lt;li&gt;软可达：不是可达并被SoftReference指向的对象是软可达的，垃圾回收器在内存实在不够用时(要抛OutOfMemoryException) 可以 回收软可达对象，并尽量不回收，回收时也先回收更老的对象&lt;/li&gt;
  &lt;li&gt;弱可达：不是可达或软可达并被WeakReference指向的对象是弱可达的，垃圾回收器 必须 回收弱可达对象&lt;/li&gt;
  &lt;li&gt;可复活：当垃圾回收器在执行finalize方法时，所有的未被回收的不可达对象都有可能复活，他们就处于可复活状态&lt;/li&gt;
  &lt;li&gt;影子可达：不是可达，软可达或弱可达且不能被复活，并被PhantomReference指向的对象是影子可达的&lt;/li&gt;
  &lt;li&gt;不可达：finalize方法执行完后还是不可达的对象是不可达的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SoftReference，WeakReference和PhantomReference是Java的三种引用对象，继承于Reference类，程序可以通过这3种引用来间接的引用一个对象；Reference有个clear方法，用来切断Reference和对象之间的引用了&lt;/p&gt;

&lt;p&gt;由于软可达和弱可达的对象可能会被回收，程序为了得到对象已被通知，程序可以为SoftReference和WeakReference对象提供一个队列，当Reference引用的对象被回收时，垃圾收集器调用Reference对象的clear方法并把Reference对象放到队列中，程序可以从队列里取出Reference对象来获知对象已被清除&lt;/p&gt;

&lt;p&gt;程序必须为PhantomReference对象提供一个队列，当一个对象成为影子可达时，垃圾收集器会把PhantomReference对象放到队列里，程序从队列里获取PhantomReference对象后调用clear方法后，垃圾收集器才会回收 垃圾对象；当一个对象成为影子可达时，程序是没有办法让这个对象的可达性发生变化&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过软可达可以实现内存缓存，当软可达对象未被回收时，可通过Reference的get方法获取对象&lt;/p&gt;

&lt;p&gt;通过弱可达可以达到一种效果：使用一些不由程序决定其回收时刻的对象，该对象可能存在也可能已经被回收&lt;/p&gt;

&lt;p&gt;通过影子可达可以让程序决定一个对象的释放时刻&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Dec 2016 10:00:00 +0800</pubDate>
        <link>/2016/12/07/DEEP_IN_JAVA_java_obj_finalize_and_reachability/</link>
        <guid isPermaLink="true">/2016/12/07/DEEP_IN_JAVA_java_obj_finalize_and_reachability/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java 垃圾收集</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;火车算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java 垃圾收集的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;垃圾收集算法必须要完成两件事：垃圾对象的检测 和 方法区和堆上的空间回收&lt;/p&gt;

&lt;p&gt;垃圾对象的检测有两种方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;引用计数：每个对象都有个引用计数器，当引用数为0时成为垃圾，缺点是无法检测循环引用&lt;/li&gt;
  &lt;li&gt;跟踪：从根对象开始遍历可达的对象图，不可达的都是垃圾&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;垃圾对象空间回收的算法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;压缩收集：通过把存活对象移动到堆的一端，剩余空间即为回收的空间，这样可以消除碎片&lt;/li&gt;
  &lt;li&gt;拷贝收集：通过把存活对象拷贝到一个新的区域，然后回收旧的区域，好处是垃圾对象的检测和收集同时进行，但需要更大的空间&lt;/li&gt;
  &lt;li&gt;按代收集：把堆分成不同的区域 存放不同年龄的对象，长久存活的对象就不用多次检测，提高高死亡率的对象回收效率&lt;/li&gt;
  &lt;li&gt;自适应收集：JVM根据运行时的情况自适应的选择不同的算法&lt;/li&gt;
  &lt;li&gt;火车算法：&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;火车算法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般的垃圾收集算法会导致应用程序的停顿，而停顿的时长是不可控的，为此需要使用渐进式的垃圾收集算法；渐进式垃圾收集算法不一次性的完成整个堆的垃圾收集，而只收集一部分空间；只需要控制一次收集的空间的大小即可控制并减少停顿的时间&lt;/p&gt;

&lt;p&gt;渐进式垃圾收集算法一般是按代收集，通过控制每一个代(除了成熟对象空间)的大小即可控制最长停顿时长，但最老的那个代(成熟对象空间)的大小是无法给定最大上限的(因为不适合放到其他代的对象都会放到成熟对象空间)，火车算法就是为了能在成熟对象空间中渐进的收集垃圾对象而发明的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;火车算法把 成熟对象空间 按固定长度的内存块进行划分，每个固定长度的内存块叫“车厢”，多个“车厢”组成的内存块成为一列“火车”，而成熟对象空间里就是一系列“火车”组成的空间&lt;/p&gt;

&lt;p&gt;“火车”按创建的顺序进行编号，编号小的火车里的对象都是比较老的对象，同样，一列“火车”里的“车厢”也按照创建的顺序进行编号，新创建的“车厢”会被放到“火车”尾部&lt;/p&gt;

&lt;p&gt;对象从年轻的代中晋升到成熟对象区间时，或者把它放到已存在的(非最小号吗的)“火车”的尾部“车厢”，或者新建个“火车”并放进去&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/java_gc.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么样?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;火车算法执行时首先检查序号最小的火车内的对象 是否被 成熟对象区以外或其他火车的对象引用，没有则回收这列火车&lt;/p&gt;

&lt;p&gt;否则检查序号最小的火车的序号最小的车厢：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检查是否有从 对象成熟区 以外的引用 指向 当前车厢内的对象，若有则把 被引用的对象转移到本列火车外的其他车厢，然后检查被转移的对象是否有指向原车厢的对象，有则递归转移到其他火车，若其他火车的车厢满了则新建一个车厢&lt;/li&gt;
  &lt;li&gt;检查是否有从 其他火车 的引用 指向 当前车厢内的对象，若有则把 被引用的对象转移到发起引用的火车的车厢，然后检查被转移的对象是否有指向原车厢的对象，有则递归转移到发起引用的火车，若车厢满了则新建一个车厢&lt;/li&gt;
  &lt;li&gt;检查是否有从 本列火车内的其他车厢 的引用 指向 当前车厢内的对象，若有则把 被引用的对象转移到最后一个车厢，然后检查被转移的对象是否有指向原车厢的对象，有则递归转移到最后一个车厢，若车厢满了则新建一个车厢&lt;/li&gt;
  &lt;li&gt;然后回收当前车厢&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过控制车厢的大小即可控制回收的停顿时间&lt;/p&gt;

&lt;p&gt;算法为了让检查和转移对象更高效，使用了一种 记忆集合 的数据结构，每个车厢和火车都有一个记忆集合，记忆集合里存放的是对车厢或火车的外部引用，所以当记忆集合为空时则可回收车厢或火车，当转移对象以后，也可以方便的使用记忆集合的信息更新外部引用；但转移流行对象则会导致需要更新大量外部引用&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Dec 2016 10:00:00 +0800</pubDate>
        <link>/2016/12/07/DEEP_IN_JAVA_java_gc/</link>
        <guid isPermaLink="true">/2016/12/07/DEEP_IN_JAVA_java_gc/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java的类型装载</title>
        <description>
&lt;p&gt;&lt;strong&gt;本文是对Java的类型装载的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Java有多种类装载器，其中一个虚拟机内置的叫 启动类装载器，用户自定义的类装载器都需要继承ClassLoader&lt;/p&gt;

&lt;p&gt;有两种方式可以触发类型的装载，一种是使用forName、classloader等来装载类型，一种是程序使用了新的类型时虚拟机解析符号引用前装载类型&lt;/p&gt;

&lt;p&gt;无论哪种方式触发类型装载，都需要装载器进行装载；当一个装载器装载类型时使用 双亲委派模型，也就是本装载器 装载类之前先用parent装载器来装载；除了启动类装载器外，每个装载器都有一个parent装载器，这样就组成了一个装载器链；所以每个类装载器得到装载请求时可能是通过其他装载器装载的；&lt;/p&gt;

&lt;p&gt;真正装载类型的装载器被称为 定义类型装载器，装载器链上从 定义类型装载器 到 开始接受装载请求的装载器 都被称为 初始类型装载器&lt;/p&gt;

&lt;p&gt;每个被装载的类型都有一个指向其 定义类型装载器的引用；而每个装载器都会保存一个类型列表，列表里存放的每个类型 都是该装载器作为其初始类型装载器的类型&lt;/p&gt;

&lt;p&gt;一个类型的装载流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当一个装载器接收到装载请求时，首先检查其类型列表里是否已经存在该类型，有则返回该类型&lt;/li&gt;
  &lt;li&gt;否则委托parent装载器装载类型，这个委托流程会一直把请求传递到 启动类型装载器&lt;/li&gt;
  &lt;li&gt;若parent装载器没办法装载类型(它会抛异常)，则由本装载器装载该类型，若装载不了则抛异常&lt;/li&gt;
  &lt;li&gt;若装载成功，则新类型会有一个指向本装载器的引用，并且装载器链上从本装载开始到开始受到装载请求的装载器都会在其类型列表里增加一个新类型&lt;/li&gt;
  &lt;li&gt;当一个类型装载了以后，虚拟机会检查其类型信息并使用本类型的 定义类型装载器 装载其父类型和所实现的接口类型(自定义的类型装载器在调用defineClass的时候进行)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;装载约束&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当两个由不同 定义类型装载器 装载的对象引用同一个限定名(包名)的类型时，在这两个定义类型装载器加载该类型的过程中，该类型必须由同一个 装载器加载&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自定义装载器例子&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;覆盖findClass，在此方法里获取class文件格式的二进制流并使用defineClass创建 Class实例并返回&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class MyClassLoader extends ClassLoader {

	private String basePath;

	MyClassLoader(String basePath) {
		this.basePath = basePath;
	}

	MyClassLoader(ClassLoader parent, String basePath) {
		super(parent);
		this.basePath = basePath;
	}

	@Override
	protected Class&amp;lt;?&amp;gt; findClass(String className) throws ClassNotFoundException {
		byte[] classData = getTypeFromBasePath(className);

		// Try to load the class from base path directory
		if (classData == null) {
			throw new ClassNotFoundException();
		}
		
		// Parse the class binary data to create a Class instance 
		return defineClass(className, classData, 0, classData.length);
	}

	private byte[] getTypeFromBasePath(String typeName) {
		String fileName = basePath + File.separator + typeName.replace(&quot;.&quot;, File.pathSeparator) + &quot;.class&quot;;

		try {
			BufferedInputStream bis = new BufferedInputStream(new FileInputStream(fileName));
			ByteArrayOutputStream out = new ByteArrayOutputStream();

			int c = bis.read();
			while (c != -1) {
				out.write(c);
				c = bis.read();
			}
			return out.toByteArray();
		} catch (IOException e) {
			return null;
		}
	}
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 07 Dec 2016 10:00:00 +0800</pubDate>
        <link>/2016/12/07/DEEP_IN_JAVA_java_class_loading/</link>
        <guid isPermaLink="true">/2016/12/07/DEEP_IN_JAVA_java_class_loading/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
  </channel>
</rss>
