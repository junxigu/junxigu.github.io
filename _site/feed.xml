<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>个人技术博客</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 22 Sep 2016 20:23:03 +0800</pubDate>
    <lastBuildDate>Thu, 22 Sep 2016 20:23:03 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Java虚拟机的构成</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;Java虚拟机的构成&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#vm&quot; id=&quot;markdown-toc-vm&quot;&gt;VM运行时&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;命令行解析&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;标注选项&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;非标准选项&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;非稳定选项&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#vm-1&quot; id=&quot;markdown-toc-vm-1&quot;&gt;VM的启动和停止&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;类加载&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;加载&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;类加载器&lt;/a&gt;                    &lt;ul&gt;
                      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;分支主题&lt;/a&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;链接&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;类型安全&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;类初始化&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;类元数据&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;解析器&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-13&quot; id=&quot;markdown-toc-section-13&quot;&gt;异常处理&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-14&quot; id=&quot;markdown-toc-section-14&quot;&gt;线程同步&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-15&quot; id=&quot;markdown-toc-section-15&quot;&gt;线程管理&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#c&quot; id=&quot;markdown-toc-c&quot;&gt;C++堆管理&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#java-1&quot; id=&quot;markdown-toc-java-1&quot;&gt;Java本地接口&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#jvm&quot; id=&quot;markdown-toc-jvm&quot;&gt;JVM致命错误处理&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-16&quot; id=&quot;markdown-toc-section-16&quot;&gt;垃圾回收&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-17&quot; id=&quot;markdown-toc-section-17&quot;&gt;分代垃圾收集&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-18&quot; id=&quot;markdown-toc-section-18&quot;&gt;新生代&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#eden&quot; id=&quot;markdown-toc-eden&quot;&gt;Eden&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#survivor&quot; id=&quot;markdown-toc-survivor&quot;&gt;Survivor&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#section-19&quot; id=&quot;markdown-toc-section-19&quot;&gt;收集过程&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-20&quot; id=&quot;markdown-toc-section-20&quot;&gt;老年代&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-21&quot; id=&quot;markdown-toc-section-21&quot;&gt;永久代&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#serial&quot; id=&quot;markdown-toc-serial&quot;&gt;Serial垃圾收集器&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#parallel&quot; id=&quot;markdown-toc-parallel&quot;&gt;Parallel垃圾收集器&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-22&quot; id=&quot;markdown-toc-section-22&quot;&gt;收集方法&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#cms&quot; id=&quot;markdown-toc-cms&quot;&gt;并行标记清除(CMS)收集器&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#g1&quot; id=&quot;markdown-toc-g1&quot;&gt;G1垃圾收集器&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jit&quot; id=&quot;markdown-toc-jit&quot;&gt;JIT编译器&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对JVM 功能的简单汇总和简述，目标读者是想了解一下JVM功能&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;java&quot;&gt;Java虚拟机的构成&lt;/h1&gt;

&lt;h2 id=&quot;vm&quot;&gt;VM运行时&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;命令行解析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;解析命令行的选项&lt;/li&gt;
  &lt;li&gt;配置VM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;选项分类&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;标注选项&lt;/h4&gt;

&lt;p&gt;JVM标注要求必须实现&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;非标准选项&lt;/h4&gt;

&lt;p&gt;(-X前缀)不强制实现&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;非稳定选项&lt;/h4&gt;

&lt;p&gt;(-XX前缀)为满足特定需求，不稳定&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数示例&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;-XX:+AffresiveOpts&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;+或-表示布尔类型的选项参数&lt;/li&gt;
  &lt;li&gt;后接JVM参数名字&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;-XX:OptName=&lt;N&gt;&lt;/N&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;JVM参数名字&lt;/li&gt;
  &lt;li&gt;后接=和value&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vm-1&quot;&gt;VM的启动和停止&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;启动器执行的操作&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;解析命令行参照&lt;/li&gt;
  &lt;li&gt;设置堆大小和JIT编译器&lt;/li&gt;
  &lt;li&gt;读取，设定环境变量&lt;/li&gt;
  &lt;li&gt;获取Main-Class&lt;/li&gt;
  &lt;li&gt;创建VM线程并初始化&lt;/li&gt;
  &lt;li&gt;加载Main-Class&lt;/li&gt;
  &lt;li&gt;执行main方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;类加载&lt;/h3&gt;

&lt;p&gt;根据类名或接口名创建对象的过程，包括3个阶段&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;加载&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;定位并读取类的二进制流&lt;/li&gt;
  &lt;li&gt;若一览其他类则先加载其他类&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-6&quot;&gt;类加载器&lt;/h5&gt;

&lt;h6 id=&quot;section-7&quot;&gt;分支主题&lt;/h6&gt;

&lt;h4 id=&quot;section-8&quot;&gt;链接&lt;/h4&gt;

&lt;p&gt;包括以下步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;检查类的语义，常量符号池；检验类型&lt;/li&gt;
  &lt;li&gt;创建静态字段并初始化为默认值&lt;/li&gt;
  &lt;li&gt;解析符合引用（可选）&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-9&quot;&gt;类型安全&lt;/h5&gt;

&lt;p&gt;Java类型由类加载器和全限定名(包括包名)唯一确定&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;类初始化&lt;/h4&gt;

&lt;p&gt;必须先初始化父类&lt;/p&gt;

&lt;h5 id=&quot;section-11&quot;&gt;类元数据&lt;/h5&gt;

&lt;p&gt;在永久代中创建Class对象的JVM内部表示&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;解析器&lt;/h3&gt;

&lt;p&gt;使用Template Table查找对应的机器码&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;异常处理&lt;/h3&gt;

&lt;p&gt;通过当前方法，当前字节码，异常对象来查找异常处理器并执行&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;线程同步&lt;/h3&gt;

&lt;p&gt;使用monitor对象实现锁定和解锁&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;线程管理&lt;/h3&gt;

&lt;h3 id=&quot;c&quot;&gt;C++堆管理&lt;/h3&gt;

&lt;h3 id=&quot;java-1&quot;&gt;Java本地接口&lt;/h3&gt;

&lt;p&gt;与非Java程序进行协作&lt;/p&gt;

&lt;h3 id=&quot;jvm&quot;&gt;JVM致命错误处理&lt;/h3&gt;

&lt;h2 id=&quot;section-16&quot;&gt;垃圾回收&lt;/h2&gt;

&lt;h3 id=&quot;section-17&quot;&gt;分代垃圾收集&lt;/h3&gt;

&lt;p&gt;原理&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;大对象生命周期短&lt;/li&gt;
  &lt;li&gt;生命周期长的对象很少引用生命周期短的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-18&quot;&gt;新生代&lt;/h4&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;空间小&lt;/li&gt;
  &lt;li&gt;收集频繁&lt;/li&gt;
  &lt;li&gt;垃圾对象多&lt;/li&gt;
  &lt;li&gt;垃圾收集效率高&lt;/li&gt;
  &lt;li&gt;一般使用复制垃圾收集法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;区域划分：Eden区和一对survivor区&lt;/p&gt;

&lt;h5 id=&quot;eden&quot;&gt;Eden&lt;/h5&gt;

&lt;p&gt;分配空间给新创建的对象&lt;/p&gt;

&lt;p&gt;空间分配方法：使用线程本地分配缓冲区和指针碰撞技术来分配空间创建对象&lt;/p&gt;

&lt;h5 id=&quot;survivor&quot;&gt;Survivor&lt;/h5&gt;

&lt;p&gt;存放从Eden存活但不足够老的对象&lt;/p&gt;

&lt;h5 id=&quot;section-19&quot;&gt;收集过程&lt;/h5&gt;

&lt;h4 id=&quot;section-20&quot;&gt;老年代&lt;/h4&gt;

&lt;p&gt;特点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对象从新生代晋升而来&lt;/li&gt;
  &lt;li&gt;空间比新生代大&lt;/li&gt;
  &lt;li&gt;占用空间增长速度较新生代慢&lt;/li&gt;
  &lt;li&gt;垃圾收集效率低&lt;/li&gt;
  &lt;li&gt;使用卡表来标记在新生代中对象的引用&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-21&quot;&gt;永久代&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;其实不作为垃圾收集分代层次的一部分&lt;/li&gt;
  &lt;li&gt;用户创建的对象不会存放在此&lt;/li&gt;
  &lt;li&gt;只存放元数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;serial&quot;&gt;Serial垃圾收集器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在新生代中使用赋值垃圾收集法&lt;/li&gt;
  &lt;li&gt;在老年代中使用标记-压缩收集法&lt;/li&gt;
  &lt;li&gt;单线程，stop-the-world收集&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;parallel&quot;&gt;Parallel垃圾收集器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;与Serial收集器的收集方法相同&lt;/li&gt;
  &lt;li&gt;使用多处理器并行收集&lt;/li&gt;
  &lt;li&gt;目标是高吞吐率&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-22&quot;&gt;收集方法&lt;/h4&gt;

&lt;h3 id=&quot;cms&quot;&gt;并行标记清除(CMS)收集器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;新生代使用复制收集法&lt;/li&gt;
  &lt;li&gt;老年代使用多步骤标记 和 清除 收集法&lt;/li&gt;
  &lt;li&gt;目标是高并发，减少停顿时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;老年代收集方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始标记：暂停应用程序，找出从外部可达的老年代对象并标记&lt;/li&gt;
  &lt;li&gt;不停顿，多线程从已标记的对象出发标记可达对象，并预清除&lt;/li&gt;
  &lt;li&gt;重新标记：暂停应用程序，多线程；并重用卡表进行重新标记&lt;/li&gt;
  &lt;li&gt;并发清除：维护空闲表，导致空间不连续和浪费，新生代回收开销增大&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;多次遍历老年代&lt;/li&gt;
  &lt;li&gt;需要更大的堆&lt;/li&gt;
  &lt;li&gt;有可能收集不干净&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;g1&quot;&gt;G1垃圾收集器&lt;/h3&gt;

&lt;h2 id=&quot;jit&quot;&gt;JIT编译器&lt;/h2&gt;

&lt;p&gt;在使用程序解析期间使用多种技术进行性能提升&lt;/p&gt;
</description>
        <pubDate>Thu, 22 Sep 2016 10:00:00 +0800</pubDate>
        <link>/2016/09/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B5%84%E6%96%99/</link>
        <guid isPermaLink="true">/2016/09/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B5%84%E6%96%99/</guid>
        
        <category>JVM</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Junit 4功能的简单汇总和简述</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;快速入门和浅尝&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#junit4&quot; id=&quot;markdown-toc-junit4&quot;&gt;Junit4功能汇总和简述&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#assertionsmatchers&quot; id=&quot;markdown-toc-assertionsmatchers&quot;&gt;Assertions和Matchers&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#assertiontext--text&quot; id=&quot;markdown-toc-assertiontext--text&quot;&gt;常用Assertion之一：断言text == text&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#matchersallof-equalto-startswith&quot; id=&quot;markdown-toc-matchersallof-equalto-startswith&quot;&gt;常用Matchers：allOf, equalTo, startsWith&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;测试用例的运行前初始化和运行后资源清理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;测试用例启动器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#junit&quot; id=&quot;markdown-toc-junit&quot;&gt;开发单元测试时，一些可重用的Junit功能组件的&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;理论：一种针对给一个单元测试用例定义各种可能的输入和前置条件的技术&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#junit-1&quot; id=&quot;markdown-toc-junit-1&quot;&gt;Junit的其他常用技术：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Junit 4功能的简单汇总和简述，目标读者是想了解一下Junit4了哪些测试工具的人员，所有代码和技术细节都是参考&lt;a href=&quot;https://github.com/junit-team/junit4/wiki#junit-usage-and-idioms&quot;&gt;Junit Wiki&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section&quot;&gt;快速入门和浅尝&lt;/h1&gt;
&lt;p&gt;此处不细说，直接参考简单明了的&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Getting-started&quot;&gt;Wiki&lt;/a&gt;吧，里面的内容就是Junit4 jar包的使用和运行简单测试实例，10分钟即可完成入门&lt;/p&gt;

&lt;h1 id=&quot;junit4&quot;&gt;Junit4功能汇总和简述&lt;/h1&gt;
&lt;p&gt;Junit4几乎所有功能官方汇总列表，可从此了解Junit4的各种功能，&lt;a href=&quot;https://github.com/junit-team/junit4/wiki&quot;&gt;官方Wiki&lt;/a&gt;相当简洁明了&lt;/p&gt;

&lt;p&gt;此处对较重要的功能稍微汇总，若有感兴趣的功能可到官方Wiki进一步了解：注意 所有代码出自Junit4 wiki&lt;/p&gt;

&lt;h2 id=&quot;assertionsmatchers&quot;&gt;Assertions和Matchers&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Assertions&quot;&gt;用法详情&lt;/a&gt;
这两种功能都是单元测试的技术基石，用来开发单元测试的断言，例如：&lt;/p&gt;

&lt;h5 id=&quot;assertiontext--text&quot;&gt;常用Assertion之一：断言text == text&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assertEquals(&quot;text&quot;, &quot;text&quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意：参数1是期望值，参数2是实际值&lt;/p&gt;

&lt;h5 id=&quot;matchersallof-equalto-startswith&quot;&gt;常用Matchers：allOf, equalTo, startsWith&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assertThat(&quot;good&quot;, allOf(equalTo(&quot;good&quot;), startsWith(&quot;good&quot;))); &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Matchers都用在assertThat断言中，代码的意思是：此处断言”good” 同时满足所有条件，条件分别是：与“good”相同，以“good”开头&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Matchers好处是：更符合断言语序，Matchers表达的比较语义更丰富和灵活，也易于开发人员扩展&lt;/strong&gt;
&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Matchers-and-assertthat&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;另：要测试 &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Exception-testing&quot;&gt;异常情况&lt;/a&gt; 是否符合预期行为;
要测试 &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Timeout-for-tests&quot;&gt;超时&lt;/a&gt; 是否符合预期行为&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;测试用例的运行前初始化和运行后资源清理&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Test-fixtures&quot;&gt;用法详情&lt;/a&gt;
主要使用&lt;strong&gt;@BeforeClass，@AfterClass, @Before 和 @After&lt;/strong&gt;来标注方法，这些标注都很容易理解&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@BeforeClass: 标注static类方法，用于对单元测试类中所有case都是用的资源进行初始化（一般用于初始化高成本资源），每个单元测试类只会运行一次&lt;/li&gt;
  &lt;li&gt;@AfterClass**：同上，功能是释放资源&lt;/li&gt;
  &lt;li&gt;@Before**：标注实例方法（单元测试用例）,用于对在每个单元测试用例运行前初始化一些变量或资源&lt;/li&gt;
  &lt;li&gt;@After**：同上，功能是释放资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;测试用例启动器&lt;/h2&gt;
&lt;p&gt;顾名思义，这些官方的启动器负责启动开发人员开发的测试用例，你可以根据用例所需要的不同功能来选择不同的启动器，官方的启动器有4个，不满足需求可以自己扩展；
此处稍微汇总
&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Test-runners&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IDE内置的单元测试启动器&lt;/strong&gt;：Eclipse，Netbeans等内置了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过命令行启动单元测试的启动器&lt;/strong&gt;：org.junit.runner.JUnitCore；使用的时候直接在命令行窗口跑单元测试
&lt;strong&gt;** JUnit4TestAdapter&lt;/strong&gt;: 在Junit3的启动器中运行 用Junit4开发的单元测试 时使用的Junit4启动器adapter&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用@RunWith来注解的class来作为单元测试启动器&lt;/strong&gt;：可以在注解里赋值来指定Junit内置的几个启动器，例如：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;1. 把一堆单元测试用例定义成一整套单元测试&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites&quot;&gt;用法详情&lt;/a&gt;*&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(Suite.class) // Sute.class是Junit的启动器
@Suite.SuiteClasses({  //里面的class都是开发人员开发的一些单元测试
	TestFeatureLogin.class,
	TestFeatureLogout.class,
	TestFeatureNavigate.class,
	TestFeatureUpdate.class
})
public class FeatureTestSuite {
	// the class remains empty,
	// used only as a holder for the above annotations
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;2. 给一个测试用例提供不同的参数&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Parameterized-tests&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(Parameterized.class)
public class FibonacciTest {
    @Parameters
    public static Collection&amp;lt;Object[]&amp;gt; data() {
        return Arrays.asList(new Object[][] {     
                 { 0, 0 }, { 1, 1 }, { 2, 1 }, { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 }  
           });
    }

    private int fInput;

    private int fExpected;

    public FibonacciTest(int input, int expected) {
        fInput= input;
        fExpected= expected;
    }

    @Test
    public void test() {
        assertEquals(fExpected, Fibonacci.compute(fInput));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;3. 把不同的单元测试用例弄成不同分类，然后使用 分类启动器 启动不同类别的单元测试&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Categories&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;4. 还有一些其他实验性和第三方启动器&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Test-runners#experimental-runners&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;5. 理论启动器：用于启动使用了“理论”技术开发单元测试的启动器，可参考下文对理论的简述&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Theories&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;junit&quot;&gt;开发单元测试时，一些可重用的Junit功能组件的&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Rules&quot;&gt;用法详情&lt;/a&gt;
通过@Rule注解来标注所使用的 组件，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Rule
public TemporaryFolder tempFolder = new TemporaryFolder();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Rule的原理是Junit在初始化一个单元测试类的时候会实例化一个@Rule标注的 rule域实例，并在每个case运行的时候都会调用 rule域实例的evaluate方法&lt;/p&gt;

&lt;p&gt;Junit所提供的组件包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TemporaryFolder：提供在测试时生成临时目录和文件的功能组件&lt;/li&gt;
  &lt;li&gt;ExternalResource：提供在测试时 自定义一些外部资源（数据库连接，socket等） 的基类，实现它提供具体的资源&lt;/li&gt;
  &lt;li&gt;ErrorCollector：测试过程中对 自认为的错误状态进行收集的工具&lt;/li&gt;
  &lt;li&gt;Verifier：提供 自定义条件校验器 的基类，实现它提供具体的校验&lt;/li&gt;
  &lt;li&gt;TestWatcher：使用它能在Junit运行每个单元测试用例的每个步骤时得到通知，从而收集用例的测试状态信息&lt;/li&gt;
  &lt;li&gt;TestName：获取测试用例名称&lt;/li&gt;
  &lt;li&gt;Timeout：测试 超时 是否符合预期行为&lt;/li&gt;
  &lt;li&gt;ExpectedException：测试 异常情况 是否符合预期行为&lt;/li&gt;
  &lt;li&gt;ClassRule：标注类的域，一般是定义一些对整个单元测试类的所有单元测试用例都有影响的域（例如外部资源等），这里不细述，请参考&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Rules&quot;&gt;用法详情&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;RuleChain：声明Rule链，链里的Rule是有顺序的&lt;/li&gt;
  &lt;li&gt;另外，可以实现TestRule接口来定制自己的Rule&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;理论：一种针对给一个单元测试用例定义各种可能的输入和前置条件的技术&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Theories&quot;&gt;用法详情&lt;/a&gt;
使用这种启动器，你可以定义测试用例的所有前置条件（不满足前置条件则忽略这个测试用例），以及不同的测试输入参数&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;junit-1&quot;&gt;Junit的其他常用技术：&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Ignoring-tests&quot;&gt;忽略（跳过）某些测试用例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Assumptions-with-assume&quot;&gt;对测试用例定义运行的先决条件 assumptions（不满足会自动跳过测试用例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Multithreaded-code-and-concurrency&quot;&gt;多线程，并发测试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Continuous-testing&quot;&gt;持续集成和测试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki#junit-usage-and-idioms&quot;&gt;maven和grade&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 21 Sep 2016 10:00:00 +0800</pubDate>
        <link>/2016/09/21/how-to-use-junit/</link>
        <guid isPermaLink="true">/2016/09/21/how-to-use-junit/</guid>
        
        <category>Junit</category>
        
        
        <category>技术</category>
        
      </item>
    
  </channel>
</rss>
