<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>个人技术博客</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 17 Dec 2016 09:29:34 +0800</pubDate>
    <lastBuildDate>Sat, 17 Dec 2016 09:29:34 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Java对象的终结与可达性</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#finalize&quot; id=&quot;markdown-toc-finalize&quot;&gt;finalize方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;对象的可达性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java对象的终结与可达性的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;finalize&quot;&gt;finalize方法&lt;/h2&gt;

&lt;p&gt;对象可以有一个finalize方法，当垃圾回收器检查到对象成为垃圾时 会调用这个对象的finalize方法；执行外finalize方法后，垃圾回收器需要重新扫描来查找垃圾对象，因为在finalize方法里对象有可能复活了(被其他存活对象引用 变成可达时)；但一个对象的finalize方法只会被执行一次，当对象复活后又变成垃圾时，垃圾收集器是不会再调用它的finalize方法的&lt;/p&gt;

&lt;p&gt;一般不用finalize方法，因为它是由垃圾收集器调用的，而垃圾回收的时机是应用不能控制的，具有不确定性&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;对象的可达性&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在垃圾收集器看来，堆中的对象有6中状态：可达，软可达，弱可达，影子可达，可复活，不可达&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可达：普通的引用指向的对象都是可达，垃圾收集器是不会回收 可达对象的&lt;/li&gt;
  &lt;li&gt;软可达：不是可达并被SoftReference指向的对象是软可达的，垃圾回收器在内存实在不够用时(要抛OutOfMemoryException) 可以 回收软可达对象，并尽量不回收，回收时也先回收更老的对象&lt;/li&gt;
  &lt;li&gt;弱可达：不是可达或软可达并被WeakReference指向的对象是弱可达的，垃圾回收器 必须 回收弱可达对象&lt;/li&gt;
  &lt;li&gt;可复活：当垃圾回收器在执行finalize方法时，所有的未被回收的不可达对象都有可能复活，他们就处于可复活状态&lt;/li&gt;
  &lt;li&gt;影子可达：不是可达，软可达或弱可达且不能被复活，并被PhantomReference指向的对象是影子可达的&lt;/li&gt;
  &lt;li&gt;不可达：finalize方法执行完后还是不可达的对象是不可达的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SoftReference，WeakReference和PhantomReference是Java的三种引用对象，继承于Reference类，程序可以通过这3种引用来间接的引用一个对象；Reference有个clear方法，用来切断Reference和对象之间的引用了&lt;/p&gt;

&lt;p&gt;由于软可达和弱可达的对象可能会被回收，程序为了得到对象已被通知，程序可以为SoftReference和WeakReference对象提供一个队列，当Reference引用的对象被回收时，垃圾收集器调用Reference对象的clear方法并把Reference对象放到队列中，程序可以从队列里取出Reference对象来获知对象已被清除&lt;/p&gt;

&lt;p&gt;程序必须为PhantomReference对象提供一个队列，当一个对象成为影子可达时，垃圾收集器会把PhantomReference对象放到队列里，程序从队列里获取PhantomReference对象后调用clear方法后，垃圾收集器才会回收 垃圾对象；当一个对象成为影子可达时，程序是没有办法让这个对象的可达性发生变化&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过软可达可以实现内存缓存，当软可达对象未被回收时，可通过Reference的get方法获取对象&lt;/p&gt;

&lt;p&gt;通过弱可达可以达到一种效果：使用一些不由程序决定其回收时刻的对象，该对象可能存在也可能已经被回收&lt;/p&gt;

&lt;p&gt;通过影子可达可以让程序决定一个对象的释放时刻&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Dec 2016 10:00:00 +0800</pubDate>
        <link>/2016/12/07/DEEP_IN_JAVA_java_obj_finalize_and_reachability/</link>
        <guid isPermaLink="true">/2016/12/07/DEEP_IN_JAVA_java_obj_finalize_and_reachability/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java 垃圾收集</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;火车算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java 垃圾收集的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;垃圾收集算法必须要完成两件事：垃圾对象的检测 和 方法区和堆上的空间回收&lt;/p&gt;

&lt;p&gt;垃圾对象的检测有两种方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;引用计数：每个对象都有个引用计数器，当引用数为0时成为垃圾，缺点是无法检测循环引用&lt;/li&gt;
  &lt;li&gt;跟踪：从根对象开始遍历可达的对象图，不可达的都是垃圾&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;垃圾对象空间回收的算法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;压缩收集：通过把存活对象移动到堆的一端，剩余空间即为回收的空间，这样可以消除碎片&lt;/li&gt;
  &lt;li&gt;拷贝收集：通过把存活对象拷贝到一个新的区域，然后回收旧的区域，好处是垃圾对象的检测和收集同时进行，但需要更大的空间&lt;/li&gt;
  &lt;li&gt;按代收集：把堆分成不同的区域 存放不同年龄的对象，长久存活的对象就不用多次检测，提高高死亡率的对象回收效率&lt;/li&gt;
  &lt;li&gt;自适应收集：JVM根据运行时的情况自适应的选择不同的算法&lt;/li&gt;
  &lt;li&gt;火车算法：&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;火车算法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般的垃圾收集算法会导致应用程序的停顿，而停顿的时长是不可控的，为此需要使用渐进式的垃圾收集算法；渐进式垃圾收集算法不一次性的完成整个堆的垃圾收集，而只收集一部分空间；只需要控制一次收集的空间的大小即可控制并减少停顿的时间&lt;/p&gt;

&lt;p&gt;渐进式垃圾收集算法一般是按代收集，通过控制每一个代(除了成熟对象空间)的大小即可控制最长停顿时长，但最老的那个代(成熟对象空间)的大小是无法给定最大上限的(因为不适合放到其他代的对象都会放到成熟对象空间)，火车算法就是为了能在成熟对象空间中渐进的收集垃圾对象而发明的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;火车算法把 成熟对象空间 按固定长度的内存块进行划分，每个固定长度的内存块叫“车厢”，多个“车厢”组成的内存块成为一列“火车”，而成熟对象空间里就是一系列“火车”组成的空间&lt;/p&gt;

&lt;p&gt;“火车”按创建的顺序进行编号，编号小的火车里的对象都是比较老的对象，同样，一列“火车”里的“车厢”也按照创建的顺序进行编号，新创建的“车厢”会被放到“火车”尾部&lt;/p&gt;

&lt;p&gt;对象从年轻的代中晋升到成熟对象区间时，或者把它放到已存在的(非最小号吗的)“火车”的尾部“车厢”，或者新建个“火车”并放进去&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/java_gc.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么样?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;火车算法执行时首先检查序号最小的火车内的对象 是否被 成熟对象区以外或其他火车的对象引用，没有则回收这列火车&lt;/p&gt;

&lt;p&gt;否则检查序号最小的火车的序号最小的车厢：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检查是否有从 对象成熟区 以外的引用 指向 当前车厢内的对象，若有则把 被引用的对象转移到本列火车外的其他车厢，然后检查被转移的对象是否有指向原车厢的对象，有则递归转移到其他火车，若其他火车的车厢满了则新建一个车厢&lt;/li&gt;
  &lt;li&gt;检查是否有从 其他火车 的引用 指向 当前车厢内的对象，若有则把 被引用的对象转移到发起引用的火车的车厢，然后检查被转移的对象是否有指向原车厢的对象，有则递归转移到发起引用的火车，若车厢满了则新建一个车厢&lt;/li&gt;
  &lt;li&gt;检查是否有从 本列火车内的其他车厢 的引用 指向 当前车厢内的对象，若有则把 被引用的对象转移到最后一个车厢，然后检查被转移的对象是否有指向原车厢的对象，有则递归转移到最后一个车厢，若车厢满了则新建一个车厢&lt;/li&gt;
  &lt;li&gt;然后回收当前车厢&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过控制车厢的大小即可控制回收的停顿时间&lt;/p&gt;

&lt;p&gt;算法为了让检查和转移对象更高效，使用了一种 记忆集合 的数据结构，每个车厢和火车都有一个记忆集合，记忆集合里存放的是对车厢或火车的外部引用，所以当记忆集合为空时则可回收车厢或火车，当转移对象以后，也可以方便的使用记忆集合的信息更新外部引用；但转移流行对象则会导致需要更新大量外部引用&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Dec 2016 10:00:00 +0800</pubDate>
        <link>/2016/12/07/DEEP_IN_JAVA_java_gc/</link>
        <guid isPermaLink="true">/2016/12/07/DEEP_IN_JAVA_java_gc/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java的类型装载</title>
        <description>
&lt;p&gt;&lt;strong&gt;本文是对Java的类型装载的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Java有多种类装载器，其中一个虚拟机内置的叫 启动类装载器，用户自定义的类装载器都需要继承ClassLoader&lt;/p&gt;

&lt;p&gt;有两种方式可以触发类型的装载，一种是使用forName、classloader等来装载类型，一种是程序使用了新的类型时虚拟机解析符号引用前装载类型&lt;/p&gt;

&lt;p&gt;无论哪种方式触发类型装载，都需要装载器进行装载；当一个装载器装载类型时使用 双亲委派模型，也就是本装载器 装载类之前先用parent装载器来装载；除了启动类装载器外，每个装载器都有一个parent装载器，这样就组成了一个装载器链；所以每个类装载器得到装载请求时可能是通过其他装载器装载的；&lt;/p&gt;

&lt;p&gt;真正装载类型的装载器被称为 定义类型装载器，装载器链上从 定义类型装载器 到 开始接受装载请求的装载器 都被称为 初始类型装载器&lt;/p&gt;

&lt;p&gt;每个被装载的类型都有一个指向其 定义类型装载器的引用；而每个装载器都会保存一个类型列表，列表里存放的每个类型 都是该装载器作为其初始类型装载器的类型&lt;/p&gt;

&lt;p&gt;一个类型的装载流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当一个装载器接收到装载请求时，首先检查其类型列表里是否已经存在该类型，有则返回该类型&lt;/li&gt;
  &lt;li&gt;否则委托parent装载器装载类型，这个委托流程会一直把请求传递到 启动类型装载器&lt;/li&gt;
  &lt;li&gt;若parent装载器没办法装载类型(它会抛异常)，则由本装载器装载该类型，若装载不了则抛异常&lt;/li&gt;
  &lt;li&gt;若装载成功，则新类型会有一个指向本装载器的引用，并且装载器链上从本装载开始到开始受到装载请求的装载器都会在其类型列表里增加一个新类型&lt;/li&gt;
  &lt;li&gt;当一个类型装载了以后，虚拟机会检查其类型信息并使用本类型的 定义类型装载器 装载其父类型和所实现的接口类型(自定义的类型装载器在调用defineClass的时候进行)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;装载约束&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当两个由不同 定义类型装载器 装载的对象引用同一个限定名(包名)的类型时，在这两个定义类型装载器加载该类型的过程中，该类型必须由同一个 装载器加载&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自定义装载器例子&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;覆盖findClass，在此方法里获取class文件格式的二进制流并使用defineClass创建 Class实例并返回&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class MyClassLoader extends ClassLoader {

	private String basePath;

	MyClassLoader(String basePath) {
		this.basePath = basePath;
	}

	MyClassLoader(ClassLoader parent, String basePath) {
		super(parent);
		this.basePath = basePath;
	}

	@Override
	protected Class&amp;lt;?&amp;gt; findClass(String className) throws ClassNotFoundException {
		byte[] classData = getTypeFromBasePath(className);

		// Try to load the class from base path directory
		if (classData == null) {
			throw new ClassNotFoundException();
		}
		
		// Parse the class binary data to create a Class instance 
		return defineClass(className, classData, 0, classData.length);
	}

	private byte[] getTypeFromBasePath(String typeName) {
		String fileName = basePath + File.separator + typeName.replace(&quot;.&quot;, File.pathSeparator) + &quot;.class&quot;;

		try {
			BufferedInputStream bis = new BufferedInputStream(new FileInputStream(fileName));
			ByteArrayOutputStream out = new ByteArrayOutputStream();

			int c = bis.read();
			while (c != -1) {
				out.write(c);
				c = bis.read();
			}
			return out.toByteArray();
		} catch (IOException e) {
			return null;
		}
	}
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 07 Dec 2016 10:00:00 +0800</pubDate>
        <link>/2016/12/07/DEEP_IN_JAVA_java_class_loading/</link>
        <guid isPermaLink="true">/2016/12/07/DEEP_IN_JAVA_java_class_loading/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>JVM简介</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#jvm&quot; id=&quot;markdown-toc-jvm&quot;&gt;JVM是什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jvm-1&quot; id=&quot;markdown-toc-jvm-1&quot;&gt;JVM的生命周期&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jvm-2&quot; id=&quot;markdown-toc-jvm-2&quot;&gt;JVM的体系结构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对JVM的基本知识的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;jvm&quot;&gt;JVM是什么&lt;/h2&gt;

&lt;p&gt;JVM有三个含义&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JVM的规范&lt;/li&gt;
  &lt;li&gt;JVM的具体实现&lt;/li&gt;
  &lt;li&gt;JVM的一个运行实例&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jvm-1&quot;&gt;JVM的生命周期&lt;/h2&gt;

&lt;p&gt;JVM实例运行时为应用程序创建非守护线程并运行运行程序，当所有非守护线程都结束时，JVM实例结束运行&lt;/p&gt;

&lt;h2 id=&quot;jvm-2&quot;&gt;JVM的体系结构&lt;/h2&gt;

&lt;p&gt;JVM规范通过对一个虚拟机实例的 子系统的行为特征，内存区构成和作用，处理的数据类型和执行的指令 这几方面的抽象描述和它们间的相互作用，来定义一个JVM所应该实现的功能和外部特征&lt;/p&gt;

&lt;p&gt;JVM的体系结构包括&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类加载子系统：负责获取class文件格式的二进制流，处理二进制流并把 类型信息装入到内存的 方法区，并未类型在堆中生成一个Class实例&lt;/li&gt;
  &lt;li&gt;运行时数据区：主要包括 方法区，堆，Java栈，PC寄存器，本地方法栈 等数据块
    &lt;ul&gt;
      &lt;li&gt;方法区：存放 加载器装载的类型信息，类型信息包括类名，类字段，类方法，超类，实现的接口，常量池，Class引用，ClassLoader引用，方法字节码等，可以被垃圾回收&lt;/li&gt;
      &lt;li&gt;堆: 存放程序运行过程中对象，可以被垃圾回收&lt;/li&gt;
      &lt;li&gt;Java栈：每个线程都会有一个私有的Java栈，线程每次条用一个方法都会压一个栈帧，栈帧包含局部变量区，操作数栈，帧数据区 等等&lt;/li&gt;
      &lt;li&gt;PC寄存器：执行引擎执行的下一条指令的地址&lt;/li&gt;
      &lt;li&gt;本地方法栈：JVM调用本地方法时使用的栈在这里生成&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;执行引擎：执行class文件里的指令，处理数据，一般使用自适应优化技术来优化执行代码&lt;/li&gt;
  &lt;li&gt;本地方法接口：是Java API本地实现 对外暴露的接口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;一个JVM的逻辑结构(图源自《深入Java虚拟机》)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/JVM_architecture.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 07 Dec 2016 10:00:00 +0800</pubDate>
        <link>/2016/12/07/DEEP_IN_JAVA_VM_JVM/</link>
        <guid isPermaLink="true">/2016/12/07/DEEP_IN_JAVA_VM_JVM/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java 类型的生命周期</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;装载&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;连接&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;验证&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;准备&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;解析&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;初始化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;卸载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java 类型的生命周期的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java的类型以class文件的形式被导入到JVM中，然后被程序使用，当不再使用时被JVM卸载&lt;/p&gt;

&lt;p&gt;JVM规范没有规定什么时候导入class文件，但规定了JVM在 主动使用 一个类型之前必须已经完成class的导入；导入包括装载，链接和初始化 3个阶段；&lt;/p&gt;

&lt;p&gt;以下场景属于对一个类型的主动使用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建一个类的实例&lt;/li&gt;
  &lt;li&gt;调用类的静态方法&lt;/li&gt;
  &lt;li&gt;使用类或接口的静态变量(非编译常量)&lt;/li&gt;
  &lt;li&gt;使用Java API的某些反射方法&lt;/li&gt;
  &lt;li&gt;初始化一个类的子类&lt;/li&gt;
  &lt;li&gt;当虚拟机启动某个被标明为启动类的类&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;子类或子接口通过继承得来的静态变量只是被动使用&lt;/p&gt;

&lt;p&gt;class的装载，链接和初始化 必须按照顺序进行，但链接中的 部分对class的验证过程会在装载中执行，链接中的解析可以延迟到初始化之后进行&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;装载&lt;/h2&gt;

&lt;p&gt;装载的过程是一个动态的扩展程序的过程，装载阶段需要完成3项任务&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过类型的全限定名产生一个class格式的二进制流&lt;/li&gt;
  &lt;li&gt;解析二进制流并在方法区中生成类型信息&lt;/li&gt;
  &lt;li&gt;创建该类型的Class实例&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;连接&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;验证&lt;/h3&gt;

&lt;p&gt;对class格式的二进制流的验证部分发生在装载期间(如检查class的文件格式，长度)，部分发生在解析期间(验证符号引用)，除此以外，验证阶段验证的内容包括各类二进制兼容性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;检查final类不能拥有子类&lt;/li&gt;
  &lt;li&gt;检查final方法不能被覆盖&lt;/li&gt;
  &lt;li&gt;确保在类型和超类之间不存在不兼容的方法声明&lt;/li&gt;
  &lt;li&gt;检查所有常量池入口相互一致&lt;/li&gt;
  &lt;li&gt;检查常量池中所有的特殊字符串&lt;/li&gt;
  &lt;li&gt;检查字节码的完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;准备&lt;/h3&gt;

&lt;p&gt;JVM为类变量分配内存并初始化为默认值&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解析&lt;/h3&gt;

&lt;p&gt;对常量池中的符号引用替换为直接引用，解析的时候可能会触发新类型的装载、准备&lt;/p&gt;

&lt;p&gt;指向类型、类变量、类方法的直接引用很可能是指向方法区的本地指针，而指向实例变量和实例方法的直接引用都是偏移&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;初始化&lt;/h2&gt;

&lt;p&gt;若父类未初始化受限初始化父类，然后执行类的静态初始化语句来初始化类变量的值&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;卸载&lt;/h2&gt;

&lt;p&gt;当一个类型的Class对象在垃圾收集时不可达 就可以触发垃圾回收(具体的回收策略由JVM的具体实现决定)，当一个类的对象能可达，则垃圾回收器则通过该对象找到方法区中的类型信息，通过方法区中的Class对象引用 触及它&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Nov 2016 10:00:00 +0800</pubDate>
        <link>/2016/11/30/DEEP_IN_JAVA_VM_Java_class_lifecycle/</link>
        <guid isPermaLink="true">/2016/11/30/DEEP_IN_JAVA_VM_Java_class_lifecycle/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java的网路移动性</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;Java的网路移动性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java的网路移动性的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;java&quot;&gt;Java的网路移动性&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java平台通过其内部机制支持在不同的主机JVM中交换 程序和数据&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务商通过网路给客户机分发服务，而服务是 可执行程序和数据的集合，Java平台能的实现这种需求&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么样？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java的平台无关性和安全性是其网络移动性的基础，还通过 动态链接，class文件的紧凑性、JAR文件 来减少程序的传送时间&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Nov 2016 10:00:00 +0800</pubDate>
        <link>/2016/11/30/DEEP_IN_JAVA_VM_Java_NEMO/</link>
        <guid isPermaLink="true">/2016/11/30/DEEP_IN_JAVA_VM_Java_NEMO/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java 代码签名和认证</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java--&quot; id=&quot;markdown-toc-java--&quot;&gt;Java对 公私钥和证书 的支持&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java---1&quot; id=&quot;markdown-toc-java---1&quot;&gt;Java对 使用私钥签名对代码 的支持&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java 代码签名和认证的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Java对代码进行数字签名和认证需要使用公私钥和证书，对数字签名的原理不熟悉可先阅读这篇简单易懂的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html&quot; title=&quot;数字签名是什么?&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;java--&quot;&gt;Java对 公私钥和证书 的支持&lt;/h3&gt;

&lt;p&gt;Java提供了内置的工具 keytool 给用户创建 公私钥和证书，用户创建的公私钥和证书是储存在一个 keystore 文件中，keystore文件中可以储存多对公私钥和证书，每对公私钥和证书会与一个 别名 相关联，用户使用 别名 来从keystore文件里获取公私钥和证书&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/java_sign_0.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个创建公私钥和证书的例子&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 把class文件打包到一个jar文件里
jar cvf example.jar *.class

// 用keytool生成一对公私钥和证书，这些公私钥和证书储存在example_key_store文件，别名是example_alias，获
// 取这对公私钥所用的密码是example_key_pass；创建过程需要填入一些信息，如果example_key_store本来不存在则
// keytool会创建一个并需要你输入example_key_store的密码(可忽略,假设使用密码example_key_store_pass)
keytool -genkey -alias example_alias -keypass example_key_pass -validity 10000 -keystore example_key_store

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;java---1&quot;&gt;Java对 使用私钥签名对代码 的支持&lt;/h3&gt;

&lt;p&gt;Java能对jar包进行签名，所以需要把class文件放到jar包里，并且能对签名后的jar包进行认证&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/java_sign_1.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/java_sign_2.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个签名的例子&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 用jarsigner对example.jar认证，需要使用别名example_alias从example_key_store里使用密码
// example_key_pass获取私钥
jarsigner -keystore example_key_store -storepass example_key_store_pass -keypass example_key_pass example.jar example_alias

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 23 Nov 2016 10:00:00 +0800</pubDate>
        <link>/2016/11/23/DEEP_IN_JAVA_VM__java_signature_and_authentication/</link>
        <guid isPermaLink="true">/2016/11/23/DEEP_IN_JAVA_VM__java_signature_and_authentication/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java的安全性</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java-&quot; id=&quot;markdown-toc-java-&quot;&gt;Java 安全性是什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java--1&quot; id=&quot;markdown-toc-java--1&quot;&gt;Java 为什么需要安全性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java--2&quot; id=&quot;markdown-toc-java--2&quot;&gt;Java 怎么样实现安全性&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;类加载器体系结构&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#class&quot; id=&quot;markdown-toc-class&quot;&gt;class文件检验器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;Java虚拟机中内置的安全特性&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#java-api&quot; id=&quot;markdown-toc-java-api&quot;&gt;安全管理器和Java API&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java的安全性的汇总和个人理解，此处的内容是针对旧版的Java&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;java-&quot;&gt;Java 安全性是什么&lt;/h2&gt;

&lt;p&gt;Java 通过其安全模型 来保护终端用户免受从网路下载的、来自不可靠来源的、恶意程序的侵犯&lt;/p&gt;

&lt;h2 id=&quot;java--1&quot;&gt;Java 为什么需要安全性&lt;/h2&gt;

&lt;p&gt;Java 程序是可从任意来源获取并运行的，因此需要保证运行这些代码时能进行限制，免受恶意代码的破坏&lt;/p&gt;

&lt;h2 id=&quot;java--2&quot;&gt;Java 怎么样实现安全性&lt;/h2&gt;

&lt;p&gt;Java 使用沙箱模型来对程序运行进行限制，防止其进行破坏，沙箱模型由一些基本组件组成&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类加载器体系结构&lt;/li&gt;
  &lt;li&gt;class文件检验器&lt;/li&gt;
  &lt;li&gt;内置于Java虚拟机(及语言)的安全特性&lt;/li&gt;
  &lt;li&gt;安全管理器及Java API&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/java_security.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前三个组成部分是为了保证JVM和它正在运行的应用程序的完整性，免受下载的恶意程序的侵犯；最后一个部分是为了保护外部资源不被JVM中运行的恶意程序侵犯&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;类加载器体系结构&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类加载器是用于动态的加载类二进制流的对象&lt;/li&gt;
  &lt;li&gt;类加载有4类：启动类加载器(java内部实现，负责加载java核心API)、标准扩展类加载器(java自带，加载ext目录下的类)、类路径类加载器(java自带，加载CLASS_PATH环境变量下的类)、自定义类加载器&lt;/li&gt;
  &lt;li&gt;类加载器使用双亲委派模式进行类的加载(非启动类加载器都有一个双亲类加载器的引用，加载类时会先让双亲加载，若双亲加载不到才自己加载)，启动类加载器 &amp;lt;- 标准扩展类加载器 &amp;lt;- 类路径类加载器 &amp;lt;- 自定义类加载器,保证可信的类由可信的类加载器优先加载&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;类加载器是可信和不可信程序的入口，通过类加载器体系机构能够在一定程度上实现可信程序和不可信程序的隔离，并能对不可信的程序的资源访问进行限制&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么样？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;类加载器体系结构的作用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;防止恶意代码干涉正常代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不同的类加载器加载的代码属于不同的命名空间(相同的类可以用不同类加载器多次加载到JVM)，不同的命名空间中的代码不能互相访问(除非显式运行交互)，达到隔离恶意代码的效果&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;守护了被信任的类库的边界&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用类加载器双亲委托模型来保证所有信任的类库都通过信任的加载器来加载，不可靠的类可以使用自定义的加载器加载&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为类创建保护域，由保护域来确定类所拥有的权限&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个类都属于一个保护域，用户可以为某个保护域的类设置资源的访问权限策略，这样就能起到限制代码权限的作用&lt;/p&gt;

&lt;h3 id=&quot;class&quot;&gt;class文件检验器&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;class文件检验器是对 类加载器加载的类 进行检查的对象&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;虚拟机不能保证 加载的类 是由合法的编译器生成的，需要对类二进制流的 结构，类型，语义，符号引用信息 进行检查，保证其完整性和健壮性&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么样？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;class文件检验器需要进行四趟扫描来完成校验&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;class文件的结构检查&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;检查class文件的结构是否满足java对于一个类型的结构的定义，包括魔数、结构、长度等&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类型数据的语义检查&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;检查各个组成部分的类型是否满足其所属的类型的定义，并检查这个类文件本身的类是否满足编译器所规定的条件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;字节码验证&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过对字节码流中的操作码，操作数进行检查，保证所有字节码都能安全的执行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;符号引用的验证&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在执行过程中第一次引用新的类型时需要进行动态链接，这时候需要对引用的合法性(存在性等)进行校验，从而保证被引用的类文件的二进制兼容性&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;Java虚拟机中内置的安全特性&lt;/h3&gt;

&lt;p&gt;JVM通过在执行过程中加入以下特性来增强程序的健壮性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类型安全的引用转换&lt;/li&gt;
  &lt;li&gt;结构化的内存访问&lt;/li&gt;
  &lt;li&gt;自动垃圾收集&lt;/li&gt;
  &lt;li&gt;数组边界检查&lt;/li&gt;
  &lt;li&gt;空引用检查&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java-api&quot;&gt;安全管理器和Java API&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安全访问器是一个对象，它能确定一个程序是否有权限访问一个受保护的资源&lt;/p&gt;

&lt;p&gt;所有对资源的访问都是通过Java API来完成的，当给应用程序赋予了一个安全管理器实例时，则Java API在访问资源前都会让安全管理器确认程序是否有权限访问资源&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过把对资源的访问封装在Java API里，然后API在访问资源前使用安全管理器确认程序是否有权限访问资源，这样就能保护外部资源不被不受信任的程序访问&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么样？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java通过签名对 受信任的代码 确定其身份和完整性&lt;/p&gt;

&lt;p&gt;一个class文件有它的代码来源，代码来源是指 代码从哪来、若被签名则是从谁那里来&lt;/p&gt;

&lt;p&gt;代码对资源所拥有的访问权限都与代码的代码来源相关联，所以在给某段代码赋予权限时，要制定其来源和所拥有权限&lt;/p&gt;

&lt;p&gt;所有的代码权限赋予都记录在一个ASCII策略文件里，文件里的内容有固定的语法，内容大意是 给 某个代码来源的代码 赋予 访问某种资源的权限&lt;/p&gt;

&lt;p&gt;类加载器 在加载类时 会给类创建一个保护域，保护域里有策略文件里定义的代码来源 和 所拥有的权限(类加载器也可以不参考策略文件)，当程序使用Java API时，安全管理器 能通过代码的保护域中的权限来确定代码是否有权访问资源&lt;/p&gt;

&lt;p&gt;安全管理器通过获取Java栈中 从资源访问调用开始到栈顶的所有栈帧，然后从每个栈帧所关联的class中获取保护域，并根据保护域中的权限来确定每个栈帧关联的类能否访问资源&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/java_access_permision_check.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 22 Nov 2016 10:00:00 +0800</pubDate>
        <link>/2016/11/22/DEEP_IN_JAVA_VM__security/</link>
        <guid isPermaLink="true">/2016/11/22/DEEP_IN_JAVA_VM__security/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java平台的无关性</title>
        <description>
&lt;p&gt;&lt;strong&gt;本文是对Java平台无关性的汇总和个人理解，此处的内容是针对旧版的Java&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Java平台的不同版本体现其 平台无关性 和 伸缩性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不同版本间支持的API集合不同&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;J2EE：适合作为高端性能的服务器上的Java平台&lt;/li&gt;
  &lt;li&gt;J2SE：适合作为浏览器上或桌面应用上的Java平台&lt;/li&gt;
  &lt;li&gt;J2ME：适合作为资源高度受限的嵌入式设备上的Java平台&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;影响Java程序的平台无关性的一些因素&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所针对的硬件平台是否已经存在相应的Java平台实现&lt;/li&gt;
  &lt;li&gt;Java程序使用的API集合在网路中的不同节点的Java平台是否存在&lt;/li&gt;
  &lt;li&gt;Java平台的版本改变后对原有程序使用的API的影响&lt;/li&gt;
  &lt;li&gt;Java程序是否使用了本地方法&lt;/li&gt;
  &lt;li&gt;Java程序是否使用了某些硬件平台厂商提供的特定扩展库&lt;/li&gt;
  &lt;li&gt;Java程序是否依赖特定Java平台的实现(及时终结，线程的优先级)&lt;/li&gt;
  &lt;li&gt;对用户界面的依赖&lt;/li&gt;
  &lt;li&gt;Java平台中的bug&lt;/li&gt;
  &lt;li&gt;不同Java平台不同实现导致的功能，性能不一致&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;开发平台无关的Java程序的步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;选定要运行的主机和设备集合&lt;/li&gt;
  &lt;li&gt;选定一个足够好的Java平台&lt;/li&gt;
  &lt;li&gt;对每个目标主机和设备选定一个Java平台实现&lt;/li&gt;
  &lt;li&gt;编写程序时只使用标准的API&lt;/li&gt;
  &lt;li&gt;编写程序时不要依赖及时终结和线程优先级&lt;/li&gt;
  &lt;li&gt;努力设计一个能在每个平台正常运行的界面&lt;/li&gt;
  &lt;li&gt;在所有目标主机和设备上测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;是否选择平台无关需要考虑性能，功能等各种因素&lt;/p&gt;

</description>
        <pubDate>Tue, 08 Nov 2016 10:00:00 +0800</pubDate>
        <link>/2016/11/08/DEEP_IN_JAVA_VM__plateform_unrelated/</link>
        <guid isPermaLink="true">/2016/11/08/DEEP_IN_JAVA_VM__plateform_unrelated/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java平台系统的基本知识</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java4&quot; id=&quot;markdown-toc-java4&quot;&gt;Java平台系统中由4个独立并相关的技术构成&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java-&quot; id=&quot;markdown-toc-java-&quot;&gt;Java平台的目标 平台无关性，安全性和网路移动性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java4-1&quot; id=&quot;markdown-toc-java4-1&quot;&gt;Java平台通过4个技术的结合来实现其目标&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;Java的劣势&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Java平台系统的基本知识的汇总和个人理解，此处的内容是针对旧版的Java&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;java4&quot;&gt;Java平台系统中由4个独立并相关的技术构成&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Java程序设计语言&lt;/li&gt;
  &lt;li&gt;Java Class文件&lt;/li&gt;
  &lt;li&gt;Java API(rt.jar等)，提供访问系统底层资源的统一接口&lt;/li&gt;
  &lt;li&gt;Java虚拟机&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/Java平台组成及关系.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;java-&quot;&gt;Java平台的目标 平台无关性，安全性和网路移动性&lt;/h2&gt;

&lt;p&gt;现代的硬件发展趋势和软件发展趋势 需要大型系统能实现 平台无关性，安全性和网路移动性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;平台无关性：程序一次开发可以在多种目标硬件平台都能使用、执行，不需要针对特定硬件平台做移植、定制&lt;/li&gt;
  &lt;li&gt;安全性：通过某种方式获得的程序的可校验，权限的可控，不同源的程序的隔离等&lt;/li&gt;
  &lt;li&gt;网路移动性：运行的状态，可执行的代码等 能在网路的不同节点中传递和执行，这是3种特性中的最高目标，前两种特性是这一特性的基本要求&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;java4-1&quot;&gt;Java平台通过4个技术的结合来实现其目标&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;java虚拟机&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;java虚拟机的主要功能是 加载class二进制(类加载器体系) 和 执行字节码(执行引擎)&lt;/p&gt;

&lt;p&gt;类加载器体系包括java平台默认实现的启动类加载器 和 用户实现的自定义类加载器，通过用户提供的类加载可以更加灵活的实现从不同地方(网路，文件系统，动态生成等) 动态地 加载类&lt;/p&gt;

&lt;p&gt;执行引擎有三种执行形式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解析执行&lt;/li&gt;
  &lt;li&gt;编译执行&lt;/li&gt;
  &lt;li&gt;自适应优化执行(动态编译高频率执行代码)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;java虚拟机是 java平台 实现 平台无关性，安全性和网路移动性 的核心&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Java虚拟机的功能有统一的规范，但不同平台上的实现可根据平台实现&lt;/li&gt;
  &lt;li&gt;不同的类加载加载的类在不同的命名空间，不能互相调用，实现隔离，所以安全&lt;/li&gt;
  &lt;li&gt;允许自定义的加载器从网路获取类所以实现网络移动性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;java class文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;java class文件更好的支持java平台的 平台无关性 和 网路移动性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java class是一种与平台无关的二进制服务形式(反例是c，c++的编译结果是平台相关的二进制代码)&lt;/li&gt;
  &lt;li&gt;java class文件格式紧凑，适合网路传输 和 按需下载，实现了网路移动性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;java API&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;java API(rt.jar等)更好的支持java平台的 平台无关性 和 安全性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java API封装了对底层系统资源的调用，对java程序提供统一的接口，实现平台无关&lt;/li&gt;
  &lt;li&gt;当java API进行任何潜在危险操作(硬盘io等)都会查询安全管理器和控制访问器来获取执行操作的权限&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;java语言&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java语言用来开发Java平台(平台无关，安全性，网络移动)应用&lt;/li&gt;
  &lt;li&gt;java语言是一种设计良好、开发效率高的语言，所以也非常适合用于开发不一定用到java平台特性的应用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;设计良好、开发效率的体现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是面向对象语言，所以比面向过程的抽象程度更高，更容易开发重用度更高的程序&lt;/li&gt;
  &lt;li&gt;垃圾收集，不用开发人员自己管理垃圾&lt;/li&gt;
  &lt;li&gt;去除指针概念，减少开发人员的失误&lt;/li&gt;
  &lt;li&gt;通过运行时类型检查抛异常来法制程序崩溃&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;java&quot;&gt;Java的劣势&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Java虚拟机执行速度可能较编译执行的程序慢&lt;/li&gt;
  &lt;li&gt;Java虚拟机的垃圾收集引入了性能的不确定性&lt;/li&gt;
  &lt;li&gt;Java虚拟机的线程管理说明模糊不清，使程序员无法了解如何调度线程&lt;/li&gt;
  &lt;li&gt;Java的平台无关性导致API的设计存在最小公分母问题&lt;/li&gt;
  &lt;li&gt;Java的class文件容易逆向工程，被窃取开发成果&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 08 Nov 2016 10:00:00 +0800</pubDate>
        <link>/2016/11/08/DEEP_IN_JAVA_VM__java_plateform/</link>
        <guid isPermaLink="true">/2016/11/08/DEEP_IN_JAVA_VM__java_plateform/</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
  </channel>
</rss>
