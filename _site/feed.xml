<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>个人技术博客</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 20 Oct 2016 17:16:06 +0800</pubDate>
    <lastBuildDate>Thu, 20 Oct 2016 17:16:06 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>面向对象系统的基本知识</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;面向对象的基本术语&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;面向对象系统的核心概念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;代码和功能的复用机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;面向对象设计的原则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对面向对象系统的基本知识的汇总和个人理解&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;面向对象的基本术语&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;方法&lt;/strong&gt; 是一个操作或一个请求，包含名字，参数和返回值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接口&lt;/strong&gt; 是一系列方法的集合，对象可以拥有接口，所以接口体现了一个对象所能完成的功能&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类型&lt;/strong&gt; 是一个接口的名字，可以理解为等同于接口，类型可以有子类型和父类性，当一个类型包含另一个类型的时即为子类型&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类&lt;/strong&gt; 定义一个对象，提供（多个）类型里方法的实现，这是对象的一个静态写照&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对象&lt;/strong&gt; 面向对象系统里运行时的基本元素，通过各个对象之间的交互（互相发送请求消息）来实现面向系统的功能;对象之间可以相互交互，对象是一个类的实例化，可以拥有多个类型&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interfaced Duck { // 类型
	void quark() // 方法
}

class ConcreteDuck implements Duck { // 类，定义了Duck类型的实现
	static void quark() {
		// real quark
	}
	
	public static void main(String[] args) {1l
		Duck d1 = new ConcreteDuck();
		Duck d2 = new ConcreteDuck();
		
		d1.quark();
		d1.quark();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;../../../../styles/images/runtime.png&quot; alt=&quot;runtime&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;面向对象系统的核心概念&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;封装&lt;/strong&gt; 把数据和对数据的操作聚合起来形成一个对象&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Duck { // 把name和quark封装成一个对象
	String name;
	
	void quark() {
		System.out.println(name + &quot; quarking...&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt; 包括两个含义&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类型继承：定义子类型，实现不同类型的替换&lt;/li&gt;
  &lt;li&gt;实现继承：实现代码的复用和实现的方法重定义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型继承举例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Quarkable {
	void quark()
}

interface Duck extends { // 类型继承
}

class ConcreteQuarkable implements Quarkable {}

class ConcreteDucke implements Quarkable {}

class Demo {
	static void runDemo(Quarkable q) {
		q.quark()
	}
	
	public static void main(String[] args) {1l
		runDemo(new ConcreteQuarkable());
		runDemo(new ConcreteDucke());
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实现继承举例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ConcreteQuarkable {
	void quark() { }
}

class ConcreteDucke1 extends ConcreteQuarkable { } // 继承了quark的实现

class ConcreteDucke2 extends ConcreteQuarkable {
	void quark() { }  // 重定义了quark的实现
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;多态&lt;/strong&gt; 在运行时动态的替换拥有相同类型的对象，如上类型继承举例&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;代码和功能的复用机制&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt; 可以实现代码的复用，缺点：这是在编译时实现的代码复用，所以是一种相对运行时来说的静态复用，不够灵活;子类会破坏父类的封装性，并对父类的代码产生依赖；优点是简单粗暴&lt;/p&gt;

&lt;p&gt;举例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class HashSet {
	...
	void addAll(Collection c) {
		for(Object o : i)
			add(o);
	}
	
	void add(Object o) {
		...
	}
	...
}

class BraokenSubSet { // broken cause dependency
	int counter = 0;

	@Override void add(Object o) { couter++; super.add(o); }
	
	@Override void addAll(Collection c) { couter += c.size(); super.addAll(c); }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;组合&lt;/strong&gt; 可以实现运行时的对象功能复用，通过多态能更加灵活; 缺点是会增加对象的数量导致增加运行时的复杂性&lt;/p&gt;

&lt;p&gt;举例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interfaced Duck {
	void quark()
}

class Demo {
	Duck d；
	
	Demo(Duck d) { this.d = d; }
	
	void setDuck(Duck d) { this.d = d; }
	
	void quark() { d.quark(); }
	
	public static void main(String[] args) {
		Demo demo = new Demo(new Duck(){
			void quark() {
				// implement version 1
			}
		});
		demo.quark();
		
		demo.setDuck((new Duck(){
			void quark() {
				// implement version 2
			}
		});
		demo.quark();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;委托&lt;/strong&gt; 通过组合来复用代码的功能，但又不需要继承&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Duck { void quark(); }

class ConcreteDucke1 extends Duck { 
	void quark() { }
}

class ConcreteDucke2 extends ConcreteQuarkable {
	ConcreteDucke1 d;
	
	ConcreteDucke2(ConcreteDucke1 d) { this.d = d; }
	
	void quark() { d.quark(); }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;参数化类型&lt;/strong&gt; 把类型作为一种可变的参数，是的代码不依赖于类型&lt;/p&gt;

&lt;p&gt;例如：List，Set，Map等&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;面向对象设计的原则&lt;/h2&gt;

&lt;p&gt;前提：视情况有取舍地使用这些原则，没有死规定&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;封装变化&lt;/strong&gt; 把可变的部分封装成对象&lt;/p&gt;

&lt;p&gt;例如：父类的两方法的实现在子类中存在着变化和重复时，应该单独封装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Bad example
class Duck {
	void fly() { System.out.println(&quot;Fly&quot;); }
	void quark() { System.out.println(&quot;quark&quot;); }
}

class ToyDuck extends Duck {
	@Override void fly() {}
	@Override void quark() { System.out.println(&quot;toy quark&quot;); }
}

class WildDuck extends Duck {
	@Override void fly() { System.out.println(&quot;Fly Height&quot;); }
	@Override void quark() { System.out.println(&quot;quark loudly&quot;); }
}

class CannotFlyWildDuck extends Duck {
	@Override void fly() {} // 重复的代码
	@Override void quark() { System.out.println(&quot;quark loudly&quot;); } // 重复的代码
}

// Good Example
interface Quarkable { void quark(); }

class Normal implements Quarkable { void quark() { System.out.println(&quot;quark&quot;); } }
class Silece implements Quarkable { void quark() {} }
class Loud implements Quarkable { void quark() { System.out.println(&quot;quark loudly&quot;); } }
class ToySound implements Quarkable { void quark() { System.out.println(&quot;toy quark&quot;); } }

abstract Duck {
	Quarkable q;
	Duck() { this.q = new Normal(); }
	void quark() { q.quark(); }
	
	void fly();
}

class Duck extends Duck {
	void fly() { System.out.println(&quot;Fly&quot;); }
}

class CannotFlyWildDuck extends Duck {
	@Override void fly() {}
}

class ToyDuck extends CannotFlyWildDuck {
	ToyDuck() { this.q = new ToySound(); }
}

class WildDuck extends Duck {
	WildDuck() { this.q = new Loud(); }
	@Override void fly() { System.out.println(&quot;Fly Height&quot;); }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;针对接口编程而非针对实现编程&lt;/strong&gt; 包括2个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户代码使用接口编程能获得动态替换具体实现的灵活性&lt;/li&gt;
  &lt;li&gt;接口的实现部分可以获得独立性和扩展性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;多用组合，少用继承&lt;/strong&gt; 对父类实现的依赖导致父类的修改影响到子类&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为了交互对象之间的松耦合设计而努力&lt;/strong&gt; 松耦合是指交互的对象之间不知道彼此的实现细节，只知道彼此拥有的接口，所以对象的具体实现的改变能互不影响&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开放–关闭原则&lt;/strong&gt; 已有代码应该对扩展开放，对修改关闭；集中精力实现最后可能改变的地方即可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;依赖倒置原则&lt;/strong&gt; 要依赖抽象的类型，不要依赖具体实现的类；编码时就是高层组件不要依赖底层组件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最少只是原则&lt;/strong&gt; 尽量减少对象间的相互依赖，否则动一发而动全身；要遵守这个原则就应该之访问以下范围内的对象的方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;该对象本身&lt;/li&gt;
  &lt;li&gt;作为参数传进来的对象&lt;/li&gt;
  &lt;li&gt;此方法所创建的对象&lt;/li&gt;
  &lt;li&gt;对象的组件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;好莱坞原则：别调用我们，我们调用你&lt;/strong&gt; 高层组件决定怎样使用提供给底层组件的钩子&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单一责任原则&lt;/strong&gt; 一个类应该只有一个引起变化的原因&lt;/p&gt;

</description>
        <pubDate>Thu, 20 Oct 2016 10:00:00 +0800</pubDate>
        <link>/2016/10/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</link>
        <guid isPermaLink="true">/2016/10/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</guid>
        
        <category>OO</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Java虚拟机的构成</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;Java虚拟机的构成&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#vm&quot; id=&quot;markdown-toc-vm&quot;&gt;VM运行时&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;命令行解析&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;标注选项&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;非标准选项&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;非稳定选项&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#vm-1&quot; id=&quot;markdown-toc-vm-1&quot;&gt;VM的启动和停止&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;类加载&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;加载&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;类加载器&lt;/a&gt;                    &lt;ul&gt;
                      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;分支主题&lt;/a&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;链接&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;类型安全&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;类初始化&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;类元数据&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;解析器&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-13&quot; id=&quot;markdown-toc-section-13&quot;&gt;异常处理&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-14&quot; id=&quot;markdown-toc-section-14&quot;&gt;线程同步&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-15&quot; id=&quot;markdown-toc-section-15&quot;&gt;线程管理&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#c&quot; id=&quot;markdown-toc-c&quot;&gt;C++堆管理&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#java-1&quot; id=&quot;markdown-toc-java-1&quot;&gt;Java本地接口&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#jvm&quot; id=&quot;markdown-toc-jvm&quot;&gt;JVM致命错误处理&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-16&quot; id=&quot;markdown-toc-section-16&quot;&gt;垃圾回收&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-17&quot; id=&quot;markdown-toc-section-17&quot;&gt;分代垃圾收集&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-18&quot; id=&quot;markdown-toc-section-18&quot;&gt;新生代&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#eden&quot; id=&quot;markdown-toc-eden&quot;&gt;Eden&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#survivor&quot; id=&quot;markdown-toc-survivor&quot;&gt;Survivor&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#section-19&quot; id=&quot;markdown-toc-section-19&quot;&gt;收集过程&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-20&quot; id=&quot;markdown-toc-section-20&quot;&gt;老年代&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-21&quot; id=&quot;markdown-toc-section-21&quot;&gt;永久代&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#serial&quot; id=&quot;markdown-toc-serial&quot;&gt;Serial垃圾收集器&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#parallel&quot; id=&quot;markdown-toc-parallel&quot;&gt;Parallel垃圾收集器&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#section-22&quot; id=&quot;markdown-toc-section-22&quot;&gt;收集方法&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#cms&quot; id=&quot;markdown-toc-cms&quot;&gt;并行标记清除(CMS)收集器&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#g1&quot; id=&quot;markdown-toc-g1&quot;&gt;G1垃圾收集器&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jit&quot; id=&quot;markdown-toc-jit&quot;&gt;JIT编译器&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对JVM 功能的简单汇总和简述，目标读者是想了解一下JVM功能&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;java&quot;&gt;Java虚拟机的构成&lt;/h1&gt;

&lt;h2 id=&quot;vm&quot;&gt;VM运行时&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;命令行解析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;解析命令行的选项&lt;/li&gt;
  &lt;li&gt;配置VM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;选项分类&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;标注选项&lt;/h4&gt;

&lt;p&gt;JVM标注要求必须实现&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;非标准选项&lt;/h4&gt;

&lt;p&gt;(-X前缀)不强制实现&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;非稳定选项&lt;/h4&gt;

&lt;p&gt;(-XX前缀)为满足特定需求，不稳定&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数示例&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;-XX:+AffresiveOpts&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;+或-表示布尔类型的选项参数&lt;/li&gt;
  &lt;li&gt;后接JVM参数名字&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;-XX:OptName=&lt;N&gt;&lt;/N&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;JVM参数名字&lt;/li&gt;
  &lt;li&gt;后接=和value&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vm-1&quot;&gt;VM的启动和停止&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;启动器执行的操作&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;解析命令行参照&lt;/li&gt;
  &lt;li&gt;设置堆大小和JIT编译器&lt;/li&gt;
  &lt;li&gt;读取，设定环境变量&lt;/li&gt;
  &lt;li&gt;获取Main-Class&lt;/li&gt;
  &lt;li&gt;创建VM线程并初始化&lt;/li&gt;
  &lt;li&gt;加载Main-Class&lt;/li&gt;
  &lt;li&gt;执行main方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;类加载&lt;/h3&gt;

&lt;p&gt;根据类名或接口名创建对象的过程，包括3个阶段&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;加载&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;定位并读取类的二进制流&lt;/li&gt;
  &lt;li&gt;若一览其他类则先加载其他类&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-6&quot;&gt;类加载器&lt;/h5&gt;

&lt;h6 id=&quot;section-7&quot;&gt;分支主题&lt;/h6&gt;

&lt;h4 id=&quot;section-8&quot;&gt;链接&lt;/h4&gt;

&lt;p&gt;包括以下步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;检查类的语义，常量符号池；检验类型&lt;/li&gt;
  &lt;li&gt;创建静态字段并初始化为默认值&lt;/li&gt;
  &lt;li&gt;解析符合引用（可选）&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-9&quot;&gt;类型安全&lt;/h5&gt;

&lt;p&gt;Java类型由类加载器和全限定名(包括包名)唯一确定&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;类初始化&lt;/h4&gt;

&lt;p&gt;必须先初始化父类&lt;/p&gt;

&lt;h5 id=&quot;section-11&quot;&gt;类元数据&lt;/h5&gt;

&lt;p&gt;在永久代中创建Class对象的JVM内部表示&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;解析器&lt;/h3&gt;

&lt;p&gt;使用Template Table查找对应的机器码&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;异常处理&lt;/h3&gt;

&lt;p&gt;通过当前方法，当前字节码，异常对象来查找异常处理器并执行&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;线程同步&lt;/h3&gt;

&lt;p&gt;使用monitor对象实现锁定和解锁&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;线程管理&lt;/h3&gt;

&lt;h3 id=&quot;c&quot;&gt;C++堆管理&lt;/h3&gt;

&lt;h3 id=&quot;java-1&quot;&gt;Java本地接口&lt;/h3&gt;

&lt;p&gt;与非Java程序进行协作&lt;/p&gt;

&lt;h3 id=&quot;jvm&quot;&gt;JVM致命错误处理&lt;/h3&gt;

&lt;h2 id=&quot;section-16&quot;&gt;垃圾回收&lt;/h2&gt;

&lt;h3 id=&quot;section-17&quot;&gt;分代垃圾收集&lt;/h3&gt;

&lt;p&gt;原理&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;大对象生命周期短&lt;/li&gt;
  &lt;li&gt;生命周期长的对象很少引用生命周期短的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-18&quot;&gt;新生代&lt;/h4&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;空间小&lt;/li&gt;
  &lt;li&gt;收集频繁&lt;/li&gt;
  &lt;li&gt;垃圾对象多&lt;/li&gt;
  &lt;li&gt;垃圾收集效率高&lt;/li&gt;
  &lt;li&gt;一般使用复制垃圾收集法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;区域划分：Eden区和一对survivor区&lt;/p&gt;

&lt;h5 id=&quot;eden&quot;&gt;Eden&lt;/h5&gt;

&lt;p&gt;分配空间给新创建的对象&lt;/p&gt;

&lt;p&gt;空间分配方法：使用线程本地分配缓冲区和指针碰撞技术来分配空间创建对象&lt;/p&gt;

&lt;h5 id=&quot;survivor&quot;&gt;Survivor&lt;/h5&gt;

&lt;p&gt;存放从Eden存活但不足够老的对象&lt;/p&gt;

&lt;h5 id=&quot;section-19&quot;&gt;收集过程&lt;/h5&gt;

&lt;h4 id=&quot;section-20&quot;&gt;老年代&lt;/h4&gt;

&lt;p&gt;特点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对象从新生代晋升而来&lt;/li&gt;
  &lt;li&gt;空间比新生代大&lt;/li&gt;
  &lt;li&gt;占用空间增长速度较新生代慢&lt;/li&gt;
  &lt;li&gt;垃圾收集效率低&lt;/li&gt;
  &lt;li&gt;使用卡表来标记在新生代中对象的引用&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-21&quot;&gt;永久代&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;其实不作为垃圾收集分代层次的一部分&lt;/li&gt;
  &lt;li&gt;用户创建的对象不会存放在此&lt;/li&gt;
  &lt;li&gt;只存放元数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;serial&quot;&gt;Serial垃圾收集器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在新生代中使用赋值垃圾收集法&lt;/li&gt;
  &lt;li&gt;在老年代中使用标记-压缩收集法&lt;/li&gt;
  &lt;li&gt;单线程，stop-the-world收集&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;parallel&quot;&gt;Parallel垃圾收集器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;与Serial收集器的收集方法相同&lt;/li&gt;
  &lt;li&gt;使用多处理器并行收集&lt;/li&gt;
  &lt;li&gt;目标是高吞吐率&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-22&quot;&gt;收集方法&lt;/h4&gt;

&lt;h3 id=&quot;cms&quot;&gt;并行标记清除(CMS)收集器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;新生代使用复制收集法&lt;/li&gt;
  &lt;li&gt;老年代使用多步骤标记 和 清除 收集法&lt;/li&gt;
  &lt;li&gt;目标是高并发，减少停顿时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;老年代收集方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始标记：暂停应用程序，找出从外部可达的老年代对象并标记&lt;/li&gt;
  &lt;li&gt;不停顿，多线程从已标记的对象出发标记可达对象，并预清除&lt;/li&gt;
  &lt;li&gt;重新标记：暂停应用程序，多线程；并重用卡表进行重新标记&lt;/li&gt;
  &lt;li&gt;并发清除：维护空闲表，导致空间不连续和浪费，新生代回收开销增大&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;多次遍历老年代&lt;/li&gt;
  &lt;li&gt;需要更大的堆&lt;/li&gt;
  &lt;li&gt;有可能收集不干净&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;g1&quot;&gt;G1垃圾收集器&lt;/h3&gt;

&lt;h2 id=&quot;jit&quot;&gt;JIT编译器&lt;/h2&gt;

&lt;p&gt;在使用程序解析期间使用多种技术进行性能提升&lt;/p&gt;
</description>
        <pubDate>Thu, 22 Sep 2016 10:00:00 +0800</pubDate>
        <link>/2016/09/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B5%84%E6%96%99/</link>
        <guid isPermaLink="true">/2016/09/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B5%84%E6%96%99/</guid>
        
        <category>JVM</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Junit 4功能的简单汇总和简述</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;快速入门和浅尝&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#junit4&quot; id=&quot;markdown-toc-junit4&quot;&gt;Junit4功能汇总和简述&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#assertionsmatchers&quot; id=&quot;markdown-toc-assertionsmatchers&quot;&gt;Assertions和Matchers&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#assertiontext--text&quot; id=&quot;markdown-toc-assertiontext--text&quot;&gt;常用Assertion之一：断言text == text&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#matchersallof-equalto-startswith&quot; id=&quot;markdown-toc-matchersallof-equalto-startswith&quot;&gt;常用Matchers：allOf, equalTo, startsWith&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;测试用例的运行前初始化和运行后资源清理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;测试用例启动器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#junit&quot; id=&quot;markdown-toc-junit&quot;&gt;开发单元测试时，一些可重用的Junit功能组件的&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;理论：一种针对给一个单元测试用例定义各种可能的输入和前置条件的技术&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#junit-1&quot; id=&quot;markdown-toc-junit-1&quot;&gt;Junit的其他常用技术：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;本文是对Junit 4功能的简单汇总和简述，目标读者是想了解一下Junit4了哪些测试工具的人员，所有代码和技术细节都是参考&lt;a href=&quot;https://github.com/junit-team/junit4/wiki#junit-usage-and-idioms&quot;&gt;Junit Wiki&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section&quot;&gt;快速入门和浅尝&lt;/h1&gt;
&lt;p&gt;此处不细说，直接参考简单明了的&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Getting-started&quot;&gt;Wiki&lt;/a&gt;吧，里面的内容就是Junit4 jar包的使用和运行简单测试实例，10分钟即可完成入门&lt;/p&gt;

&lt;h1 id=&quot;junit4&quot;&gt;Junit4功能汇总和简述&lt;/h1&gt;
&lt;p&gt;Junit4几乎所有功能官方汇总列表，可从此了解Junit4的各种功能，&lt;a href=&quot;https://github.com/junit-team/junit4/wiki&quot;&gt;官方Wiki&lt;/a&gt;相当简洁明了&lt;/p&gt;

&lt;p&gt;此处对较重要的功能稍微汇总，若有感兴趣的功能可到官方Wiki进一步了解：注意 所有代码出自Junit4 wiki&lt;/p&gt;

&lt;h2 id=&quot;assertionsmatchers&quot;&gt;Assertions和Matchers&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Assertions&quot;&gt;用法详情&lt;/a&gt;
这两种功能都是单元测试的技术基石，用来开发单元测试的断言，例如：&lt;/p&gt;

&lt;h5 id=&quot;assertiontext--text&quot;&gt;常用Assertion之一：断言text == text&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assertEquals(&quot;text&quot;, &quot;text&quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意：参数1是期望值，参数2是实际值&lt;/p&gt;

&lt;h5 id=&quot;matchersallof-equalto-startswith&quot;&gt;常用Matchers：allOf, equalTo, startsWith&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assertThat(&quot;good&quot;, allOf(equalTo(&quot;good&quot;), startsWith(&quot;good&quot;))); &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Matchers都用在assertThat断言中，代码的意思是：此处断言”good” 同时满足所有条件，条件分别是：与“good”相同，以“good”开头&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Matchers好处是：更符合断言语序，Matchers表达的比较语义更丰富和灵活，也易于开发人员扩展&lt;/strong&gt;
&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Matchers-and-assertthat&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;另：要测试 &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Exception-testing&quot;&gt;异常情况&lt;/a&gt; 是否符合预期行为;
要测试 &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Timeout-for-tests&quot;&gt;超时&lt;/a&gt; 是否符合预期行为&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;测试用例的运行前初始化和运行后资源清理&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Test-fixtures&quot;&gt;用法详情&lt;/a&gt;
主要使用&lt;strong&gt;@BeforeClass，@AfterClass, @Before 和 @After&lt;/strong&gt;来标注方法，这些标注都很容易理解&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@BeforeClass: 标注static类方法，用于对单元测试类中所有case都是用的资源进行初始化（一般用于初始化高成本资源），每个单元测试类只会运行一次&lt;/li&gt;
  &lt;li&gt;@AfterClass**：同上，功能是释放资源&lt;/li&gt;
  &lt;li&gt;@Before**：标注实例方法（单元测试用例）,用于对在每个单元测试用例运行前初始化一些变量或资源&lt;/li&gt;
  &lt;li&gt;@After**：同上，功能是释放资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;测试用例启动器&lt;/h2&gt;
&lt;p&gt;顾名思义，这些官方的启动器负责启动开发人员开发的测试用例，你可以根据用例所需要的不同功能来选择不同的启动器，官方的启动器有4个，不满足需求可以自己扩展；
此处稍微汇总
&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Test-runners&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IDE内置的单元测试启动器&lt;/strong&gt;：Eclipse，Netbeans等内置了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过命令行启动单元测试的启动器&lt;/strong&gt;：org.junit.runner.JUnitCore；使用的时候直接在命令行窗口跑单元测试
&lt;strong&gt;** JUnit4TestAdapter&lt;/strong&gt;: 在Junit3的启动器中运行 用Junit4开发的单元测试 时使用的Junit4启动器adapter&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用@RunWith来注解的class来作为单元测试启动器&lt;/strong&gt;：可以在注解里赋值来指定Junit内置的几个启动器，例如：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;1. 把一堆单元测试用例定义成一整套单元测试&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites&quot;&gt;用法详情&lt;/a&gt;*&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(Suite.class) // Sute.class是Junit的启动器
@Suite.SuiteClasses({  //里面的class都是开发人员开发的一些单元测试
	TestFeatureLogin.class,
	TestFeatureLogout.class,
	TestFeatureNavigate.class,
	TestFeatureUpdate.class
})
public class FeatureTestSuite {
	// the class remains empty,
	// used only as a holder for the above annotations
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;2. 给一个测试用例提供不同的参数&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Parameterized-tests&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(Parameterized.class)
public class FibonacciTest {
    @Parameters
    public static Collection&amp;lt;Object[]&amp;gt; data() {
        return Arrays.asList(new Object[][] {     
                 { 0, 0 }, { 1, 1 }, { 2, 1 }, { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 }  
           });
    }

    private int fInput;

    private int fExpected;

    public FibonacciTest(int input, int expected) {
        fInput= input;
        fExpected= expected;
    }

    @Test
    public void test() {
        assertEquals(fExpected, Fibonacci.compute(fInput));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;3. 把不同的单元测试用例弄成不同分类，然后使用 分类启动器 启动不同类别的单元测试&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Categories&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;4. 还有一些其他实验性和第三方启动器&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Test-runners#experimental-runners&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;5. 理论启动器：用于启动使用了“理论”技术开发单元测试的启动器，可参考下文对理论的简述&lt;/em&gt; &lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Theories&quot;&gt;用法详情&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;junit&quot;&gt;开发单元测试时，一些可重用的Junit功能组件的&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Rules&quot;&gt;用法详情&lt;/a&gt;
通过@Rule注解来标注所使用的 组件，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Rule
public TemporaryFolder tempFolder = new TemporaryFolder();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Rule的原理是Junit在初始化一个单元测试类的时候会实例化一个@Rule标注的 rule域实例，并在每个case运行的时候都会调用 rule域实例的evaluate方法&lt;/p&gt;

&lt;p&gt;Junit所提供的组件包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TemporaryFolder：提供在测试时生成临时目录和文件的功能组件&lt;/li&gt;
  &lt;li&gt;ExternalResource：提供在测试时 自定义一些外部资源（数据库连接，socket等） 的基类，实现它提供具体的资源&lt;/li&gt;
  &lt;li&gt;ErrorCollector：测试过程中对 自认为的错误状态进行收集的工具&lt;/li&gt;
  &lt;li&gt;Verifier：提供 自定义条件校验器 的基类，实现它提供具体的校验&lt;/li&gt;
  &lt;li&gt;TestWatcher：使用它能在Junit运行每个单元测试用例的每个步骤时得到通知，从而收集用例的测试状态信息&lt;/li&gt;
  &lt;li&gt;TestName：获取测试用例名称&lt;/li&gt;
  &lt;li&gt;Timeout：测试 超时 是否符合预期行为&lt;/li&gt;
  &lt;li&gt;ExpectedException：测试 异常情况 是否符合预期行为&lt;/li&gt;
  &lt;li&gt;ClassRule：标注类的域，一般是定义一些对整个单元测试类的所有单元测试用例都有影响的域（例如外部资源等），这里不细述，请参考&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Rules&quot;&gt;用法详情&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;RuleChain：声明Rule链，链里的Rule是有顺序的&lt;/li&gt;
  &lt;li&gt;另外，可以实现TestRule接口来定制自己的Rule&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;理论：一种针对给一个单元测试用例定义各种可能的输入和前置条件的技术&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Theories&quot;&gt;用法详情&lt;/a&gt;
使用这种启动器，你可以定义测试用例的所有前置条件（不满足前置条件则忽略这个测试用例），以及不同的测试输入参数&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;junit-1&quot;&gt;Junit的其他常用技术：&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Ignoring-tests&quot;&gt;忽略（跳过）某些测试用例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Assumptions-with-assume&quot;&gt;对测试用例定义运行的先决条件 assumptions（不满足会自动跳过测试用例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Multithreaded-code-and-concurrency&quot;&gt;多线程，并发测试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki/Continuous-testing&quot;&gt;持续集成和测试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/junit-team/junit4/wiki#junit-usage-and-idioms&quot;&gt;maven和grade&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 21 Sep 2016 10:00:00 +0800</pubDate>
        <link>/2016/09/21/how-to-use-junit/</link>
        <guid isPermaLink="true">/2016/09/21/how-to-use-junit/</guid>
        
        <category>Junit</category>
        
        
        <category>技术</category>
        
      </item>
    
  </channel>
</rss>
