<!DOCTYPE html>
<html>

  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Java反射API简介</title>

	<link rel="stylesheet" href="/styles/css/index.css">
	<link rel="stylesheet" href="/styles/css/fontawesome/css/font-awesome.min.css">
	<link rel="canonical" href="/2017/05/12/java%E5%8F%8D%E5%B0%84api%E7%AE%80%E4%BB%8B/">
	<link rel="alternate" type="application/rss+xml" title="Jun Xi Gu 的博客" href="/feed.xml">
	
	<meta name="description" content="顾俊喜;个人博客">

	<script src="/styles/js/jquery.min.js"></script>
	<!--[if lt IE 9]>
    	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  	<![endif]-->
  	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?94be4b0f9fc5d94cc0d0415ea6761ae9";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
  	<style type="text/css">
	  	.docs-content{
	  		margin-bottom: 10px;
	  	}
  	</style>
</head>

  <body class="index">

    <header class="navbar navbar-inverse navbar-fixed-top docs-nav" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">    
        <li>
          <a href="/">主页</a>
        </li>
        <li>
          <a href="/categories/">分类博客</a>
        </li>
        <li>
          <a href="/tag">标签博客</a>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">关于<b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li><a rel="nofollow" target="_blank" href="https://github.com/junxigu/">Github</a></li>
            <li><a rel="nofollow" target="_blank" href="https://github.com/luoyan35714/LessOrMore.git">本博客模板</a></li>
          </ul>
        </li>
      </ul>
    </nav>
  </div>
</header>
    <div class="docs-header" id="content">
  <div class="container">
  	
  		<!--
		    <h1>Java反射API简介</h1>
		    <p>Post on May 12, 2017 by <a href="/about">Jun Xi Gu</a></p>
		-->
		    <h1>Stay Hungry Stay Foolish</h1>
    
  </div>
</div>
    
      
<div class="banner">
  <div class="container">
  	
    	<a href="/categories/#Java-ref">Java</a>	/
    	<a href="/tag/#Reflection-ref">Reflection</a>
    
  </div>
</div>

    

    <div class="container docs-container">
  <div class="row">
    <div class="col-md-3">
      <div class="sidebar hidden-print" role="complementary">
        <div id="navigation">
  <h1>目录</h1>
  <ul class="nav sidenav">
<!--
    
      
      
      
      

      
        <li><a href="#year_2017">2017</a>
          <ul class="nav">
            <li><a href="#month_2017_May">May</a></li>
      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_February">February</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_January">January</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
        
            </ul>
          </li>
          <li><a href="#year_2016">2016</a>
            <ul class="nav">
              <li><a href="#month_2016_December">December</a></li>
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2016_November">November</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2016_October">October</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2016_September">September</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            </ul>
          </li>
      
    
-->
  </ul>
</div> 
      </div>
    </div>
    <div class="col-md-9" role="main">
      <div class="panel docs-content">
        <div class="wrapper">
            <header class="post-header">
              <h1 class="post-title">Java反射API简介</h1>
              <!--
                <p class="post-meta">May 12, 2017</p>
              -->
              <div class="meta">Posted on <span class="postdate">May 12, 2017</span> By <a target="_blank" href="">Jun Xi Gu</a></div>
              <br />
            </header>
            <article class="post-content">
              <ul id="markdown-toc">
  <li><a href="#类class反射api" id="markdown-toc-类class反射api">类(Class)反射API</a>    <ul>
      <li><a href="#获取class对象的api" id="markdown-toc-获取class对象的api">获取Class对象的API</a></li>
      <li><a href="#获取类的修饰符和类型信息" id="markdown-toc-获取类的修饰符和类型信息">获取类的修饰符和类型信息</a></li>
      <li><a href="#获取类成员信息" id="markdown-toc-获取类成员信息">获取类成员信息</a></li>
    </ul>
  </li>
  <li><a href="#域field反射api" id="markdown-toc-域field反射api">域(Field)反射API</a>    <ul>
      <li><a href="#获取域的类型和泛型信息" id="markdown-toc-获取域的类型和泛型信息">获取域的类型和泛型信息</a></li>
      <li><a href="#获取域的访问修饰符" id="markdown-toc-获取域的访问修饰符">获取域的访问修饰符</a></li>
      <li><a href="#获取和设置域的值" id="markdown-toc-获取和设置域的值">获取和设置域的值</a></li>
    </ul>
  </li>
  <li><a href="#方法method反射api" id="markdown-toc-方法method反射api">方法(Method)反射API</a>    <ul>
      <li><a href="#获取方法的类型信息" id="markdown-toc-获取方法的类型信息">获取方法的类型信息</a></li>
      <li><a href="#获取方法的参数的正式名字" id="markdown-toc-获取方法的参数的正式名字">获取方法的参数的正式名字</a></li>
      <li><a href="#获取方法的访问修饰符" id="markdown-toc-获取方法的访问修饰符">获取方法的访问修饰符</a></li>
      <li><a href="#用method的反射api来调用方法" id="markdown-toc-用method的反射api来调用方法">用Method的反射API来调用方法</a></li>
    </ul>
  </li>
  <li><a href="#构造器constructors的反射api" id="markdown-toc-构造器constructors的反射api">构造器(Constructors)的反射API</a>    <ul>
      <li><a href="#获取构造器声明中的类型信息" id="markdown-toc-获取构造器声明中的类型信息">获取构造器声明中的类型信息</a></li>
      <li><a href="#获取构造器的访问修饰符" id="markdown-toc-获取构造器的访问修饰符">获取构造器的访问修饰符</a></li>
      <li><a href="#创建对象" id="markdown-toc-创建对象">创建对象</a></li>
    </ul>
  </li>
  <li><a href="#数组array反射api" id="markdown-toc-数组array反射api">数组(Array)反射API</a>    <ul>
      <li><a href="#获取数组和数组元素的类型" id="markdown-toc-获取数组和数组元素的类型">获取数组和数组元素的类型</a></li>
      <li><a href="#创建数组" id="markdown-toc-创建数组">创建数组</a></li>
      <li><a href="#获取和设置数组元素" id="markdown-toc-获取和设置数组元素">获取和设置数组元素</a></li>
    </ul>
  </li>
  <li><a href="#枚举enum反射api" id="markdown-toc-枚举enum反射api">枚举(Enum)反射API</a></li>
  <li><a href="#参考文献" id="markdown-toc-参考文献">参考文献</a></li>
</ul>

<p><strong>本文是对Java管网上反射API教程的个人总结，代码和测试用例均来自管网</strong></p>

<hr />

<p>Java反射 是一种强大的工具，能让开发人员在运行时获取和操作类，接口，域，方法的信息，其应用范围不广，但能跨过静态类型的约束。</p>

<p><strong>应用范围：</strong></p>

<ul>
  <li>动态的扩展类的功能：如动态代理</li>
  <li>类信息浏览器、可视化开发工具</li>
  <li>调试器、测试工具</li>
</ul>

<p>虽然反射很强大，但适用场景不多，而且使用是有代价的，所以能不用就不用</p>

<p><strong>代价</strong></p>

<ul>
  <li>性能不足：因缺少编译器的代码优化</li>
  <li>安全约束情况复杂：动态的代码可能运行在不同的安全管理器中，受到不同的安全约束</li>
  <li>破坏封装：通过反射能无视修饰符的限制来访问类的成员</li>
</ul>

<p>Java反射常用的API主要包括访问和操作类，方法，域，构造器，数组和枚举的API</p>

<h1 id="类class反射api">类(Class)反射API</h1>

<p>常用的类反射API主要包括：获取Class对象，获取类的访问修饰符和各种类型信息，获取类成员的信息</p>

<h2 id="获取class对象的api">获取Class对象的API</h2>

<p><strong>Object.getClass()</strong> 通过一个对象来获取它的class的对象，例如</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Class&lt;String&gt; c = "foo".getClass();

Set&lt;String&gt; s = new HashSet&lt;String&gt;();
Class&lt;Set&lt;String&gt;&gt;&gt; c = s.getClass();

boolean b;
Class c = b.getClass(); // compile-time error

</code></pre>
</div>

<p>注意，基本类型的变量不能通过getClass获取Class对象</p>

<p><strong>.class语法</strong> 通过“.class”语法来获取Class对象</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Class&lt;Boolean&gt; c = boolean.class; // boxing type

Class&lt;PrintStream&gt; c = java.io.PrintStream.class;

Class&lt;int[][][]&gt; c = int[][][].class;

</code></pre>
</div>

<p><strong>Class.forName()</strong> 通过Class的静态方法和class的全限定名来获取Class对象</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Class c = Class.forName("com.duke.MyLocaleServiceProvider");

Class cStringArray = Class.forName("[[Ljava.lang.String;");

</code></pre>
</div>

<p><strong>.type语法</strong> 可以通过.TYPE语法来获取基本类型包装类的Class对象，但其实可以用.class语法代替</p>

<p><strong>Class的一些其他API</strong></p>

<p>Class.getSuperclass() 获取父类</p>

<p><code class="highlighter-rouge">Class c = javax.swing.JButton.class.getSuperclass();</code></p>

<p>Class.getClasses() 获取所有在Class对象中声明的或继承而来的嵌套类，接口，枚举</p>

<p><code class="highlighter-rouge">Class&lt;?&gt;[] c = Character.class.getClasses();</code></p>

<p>Class.getDeclaredClasses() 获取所有在Class对象中声明的嵌套类，接口，枚举</p>

<p><code class="highlighter-rouge">Class&lt;?&gt;[] c = Character.class.getDeclaredClasses();</code></p>

<p>Class.getDeclaringClass()<br />
java.lang.reflect.Field.getDeclaringClass()<br />
java.lang.reflect.Method.getDeclaringClass()<br />
java.lang.reflect.Constructor.getDeclaringClass()</p>

<p>嵌套类和成员通过以上API来获取外层的类，但匿名类需要不行，需要使用Class.getEnclosingClass</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import java.lang.reflect.Field;

Field f = System.class.getField("out");
Class c = f.getDeclaringClass();
The field out is declared in System.
public class MyClass {
	static Object o = new Object() {
		public void m() {} 
	};
	static Class&lt;c&gt; = o.getClass().getEnclosingClass();
}

</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Class c = Thread.State.class().getEnclosingClass();
The enclosing class of the enum Thread.State is Thread.
public class MyClass {
	static Object o = new Object() { 
		public void m() {} 
	};
	static Class&lt;c&gt; = o.getClass().getEnclosingClass(); //MyClass
}

</code></pre>
</div>

<h2 id="获取类的修饰符和类型信息">获取类的修饰符和类型信息</h2>

<p><strong>Class.getModifiers()</strong> 通过Class.getModifiers()来获取类的修饰符，另外java.lang.reflect.Modifier 有很多API来查看修饰符信息</p>

<p><strong>c.getTypeParameters</strong> 通过c.getTypeParameters来获取class声明中的泛型变量</p>

<p><strong>c.getGenericInterfaces()</strong> 通过c.getGenericInterfaces()获取class所实现的接口</p>

<p><strong>c.getSuperclass()</strong> 通过c.getSuperclass()获取class的父类</p>

<p><strong>c.getAnnotations()</strong> 通过c.getAnnotations()获取class声明中的注解</p>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/class/classModifiers.html">示例代码来源</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import static java.lang.System.out;

public class ClassDeclarationSpy {
	public static void main(String... args) {
	try {
		Class&lt;?&gt; c = Class.forName(args[0]);
		out.format("Class:%n  %s%n%n", c.getCanonicalName());
		out.format("Modifiers:%n  %s%n%n",
			   Modifier.toString(c.getModifiers()));

		out.format("Type Parameters:%n");
		TypeVariable[] tv = c.getTypeParameters();
		if (tv.length != 0) {
		out.format("  ");
		for (TypeVariable t : tv)
			out.format("%s ", t.getName());
		out.format("%n%n");
		} else {
		out.format("  -- No Type Parameters --%n%n");
		}

		out.format("Implemented Interfaces:%n");
		Type[] intfs = c.getGenericInterfaces();
		if (intfs.length != 0) {
		for (Type intf : intfs)
			out.format("  %s%n", intf.toString());
		out.format("%n");
		} else {
		out.format("  -- No Implemented Interfaces --%n%n");
		}

		out.format("Inheritance Path:%n");
		List&lt;Class&gt; l = new ArrayList&lt;Class&gt;();
		printAncestor(c, l);
		if (l.size() != 0) {
		for (Class&lt;?&gt; cl : l)
			out.format("  %s%n", cl.getCanonicalName());
		out.format("%n");
		} else {
		out.format("  -- No Super Classes --%n%n");
		}

		out.format("Annotations:%n");
		Annotation[] ann = c.getAnnotations();
		if (ann.length != 0) {
		for (Annotation a : ann)
			out.format("  %s%n", a.toString());
		out.format("%n");
		} else {
		out.format("  -- No Annotations --%n%n");
		}

		// production code should handle this exception more gracefully
	} catch (ClassNotFoundException x) {
		x.printStackTrace();
	}
	}

	private static void printAncestor(Class&lt;?&gt; c, List&lt;Class&gt; l) {
	Class&lt;?&gt; ancestor = c.getSuperclass();
 	if (ancestor != null) {
		l.add(ancestor);
		printAncestor(ancestor, l);
 	}
	}
}

</code></pre>
</div>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/class/classModifiers.html">一些测试示例</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ java ClassDeclarationSpy java.util.concurrent.ConcurrentNavigableMap
Class:
  java.util.concurrent.ConcurrentNavigableMap

Modifiers:
  public abstract interface

Type Parameters:
  K V

Implemented Interfaces:
  java.util.concurrent.ConcurrentMap&lt;K, V&gt;
  java.util.NavigableMap&lt;K, V&gt;

Inheritance Path:
  -- No Super Classes --

Annotations:
  -- No Annotations --
  
// 注意，对象数组的类型文本以[L开头
$ java ClassDeclarationSpy "[Ljava.lang.String;"
Class:
  java.lang.String[]

Modifiers:
  public abstract final

Type Parameters:
  -- No Type Parameters --

Implemented Interfaces:
  interface java.lang.Cloneable
  interface java.io.Serializable

Inheritance Path:
  java.lang.Object

Annotations:
  -- No Annotations --
  
$ java ClassDeclarationSpy java.io.InterruptedIOException
Class:
  java.io.InterruptedIOException

Modifiers:
  public

Type Parameters:
  -- No Type Parameters --

Implemented Interfaces:
  -- No Implemented Interfaces --

Inheritance Path:
  java.io.IOException
  java.lang.Exception
  java.lang.Throwable
  java.lang.Object

Annotations:
  -- No Annotations --

// 注意，该类已经废弃，所以能获取到运行时标注Deprecated
$ java ClassDeclarationSpy java.security.Identity
Class:
  java.security.Identity

Modifiers:
  public abstract

Type Parameters:
  -- No Type Parameters --

Implemented Interfaces:
  interface java.security.Principal
  interface java.io.Serializable

Inheritance Path:
  java.lang.Object

Annotations:
  @java.lang.Deprecated()
  
  
</code></pre>
</div>

<h2 id="获取类成员信息">获取类成员信息</h2>

<p>常用的API包括获取类的域，方法和构造器对象</p>

<p><strong>获取域的API</strong></p>

<ul>
  <li>getDeclaredField()</li>
  <li>getField()</li>
  <li>getDeclaredFields()</li>
  <li>getFields()</li>
</ul>

<p><strong>获取方法的API</strong></p>

<ul>
  <li>getDeclaredMethod()</li>
  <li>getMethod()</li>
  <li>getDeclaredMethods()</li>
  <li>getMethods()</li>
</ul>

<p><strong>获取构造器的API</strong></p>

<ul>
  <li>getDeclaredConstructor()</li>
  <li>getConstructor()</li>
  <li>getDeclaredConstructors()</li>
  <li>getConstructors()</li>
</ul>

<p><strong>获取嵌套类的API</strong></p>

<ul>
  <li>getDeclaredClasses()</li>
  <li>getClasses()</li>
</ul>

<p>getDeclared* 的API都是获取类直接声明(包括private)的成员，而get* 的API能获得public的类声明和继承而来的成员</p>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/class/classMembers.html">完整代码示例</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>void printMembers(Member[] mbrs, String s) {
	for (Member mbr : mbrs) {
		if (mbr instanceof Field)
			System.out.format("  %s%n", ((Field)mbr).toGenericString());
	   else if (mbr instanceof Constructor)
			System.out.format("  %s%n", ((Constructor)mbr).toGenericString());
	   else if (mbr instanceof Method)
			System.out.format("  %s%n", ((Method)mbr).toGenericString());
	}
}

private static void printClasses(Class&lt;?&gt; c) {
	Class&lt;?&gt;[] clss = c.getClasses();
	for (Class&lt;?&gt; cls : clss)
		System.out.format("  %s%n", cls.getCanonicalName());
}

</code></pre>
</div>

<h1 id="域field反射api">域(Field)反射API</h1>

<p>域的反射API包括获取域的类型，泛型信息，访问修饰符，获取和修改域的值API</p>

<p>可以通过Class的getFields()和getDeclaredField()来获取域对象</p>

<h2 id="获取域的类型和泛型信息">获取域的类型和泛型信息</h2>

<p>Field.getType 获取域类型</p>

<p>Field.getGenericType 获取带泛型声明的域类型</p>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/member/fieldTypes.html">完整代码示例</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>import java.lang.reflect.Field;
import java.util.List;

public class FieldSpy&lt;T&gt; {
	public boolean[][] b = {
		{ false, false }, 
		{ true, true } 
	};
	public String name  = "Alice";
	public List&lt;Integer&gt; list;
	public T val;

	public static void main(String... args) {
		try {
			Class&lt;?&gt; c = Class.forName(args[0]);
			Field f = c.getField(args[1]);
			System.out.format("Type: %s%n", f.getType());
			System.out.format("GenericType: %s%n", f.getGenericType());
	
			// production code should handle these exceptions more gracefully
		} catch (ClassNotFoundException x) {
			x.printStackTrace();
		} catch (NoSuchFieldException x) {
			x.printStackTrace();
		}
	}
}

$ java FieldSpy FieldSpy b
Type: class [[Z
GenericType: class [[Z
$ java FieldSpy FieldSpy name
Type: class java.lang.String
GenericType: class java.lang.String
$ java FieldSpy FieldSpy list
Type: interface java.util.List
GenericType: java.util.List&lt;java.lang.Integer&gt;
$ java FieldSpy FieldSpy val
Type: class java.lang.Object
GenericType: T

</code></pre>
</div>

<h2 id="获取域的访问修饰符">获取域的访问修饰符</h2>

<p>Field.getModifiers() 获取访问修饰符信息</p>

<p>Field.isSynthetic() 判断域是否是编译器生成的</p>

<p>Field.isEnumCostant() 判断域是否是枚举实例</p>

<h2 id="获取和设置域的值">获取和设置域的值</h2>

<p>主要通过以下API</p>

<ul>
  <li>Field.get</li>
  <li>Field.get*</li>
  <li>Field.set</li>
  <li>Field.set*</li>
</ul>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/member/fieldValues.html">完整代码示例</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>import java.lang.reflect.Field;
import java.util.Arrays;
import static java.lang.System.out;

enum Tweedle { DEE, DUM }

public class Book {
    public long chapters = 0;
    public String[] characters = { "Alice", "White Rabbit" };
    public Tweedle twin = Tweedle.DEE;

    public static void main(String... args) {
			Book book = new Book();
			String fmt = "%6S:  %-12s = %s%n";
		
			try {
			    Class&lt;?&gt; c = book.getClass();
		
			    Field chap = c.getDeclaredField("chapters");
			    out.format(fmt, "before", "chapters", book.chapters);
		  	    chap.setLong(book, 12);
			    out.format(fmt, "after", "chapters", chap.getLong(book));
		
			    Field chars = c.getDeclaredField("characters");
			    out.format(fmt, "before", "characters",
				       Arrays.asList(book.characters));
			    String[] newChars = { "Queen", "King" };
			    chars.set(book, newChars);
			    out.format(fmt, "after", "characters",
				       Arrays.asList(book.characters));
		
			    Field t = c.getDeclaredField("twin");
			    out.format(fmt, "before", "twin", book.twin);
			    t.set(book, Tweedle.DUM);
			    out.format(fmt, "after", "twin", t.get(book));
		
		        // production code should handle these exceptions more gracefully
			} catch (NoSuchFieldException x) {
			    x.printStackTrace();
			} catch (IllegalAccessException x) {
			    x.printStackTrace();
			}
    }
}

// 结果：
$ java Book
BEFORE:  chapters     = 0
 AFTER:  chapters     = 12
BEFORE:  characters   = [Alice, White Rabbit]
 AFTER:  characters   = [Queen, King]
BEFORE:  twin         = DEE
 AFTER:  twin         = DUM

</code></pre>
</div>

<h1 id="方法method反射api">方法(Method)反射API</h1>

<p>常用的方法反射API包括：获取方法声明中的类型信息，参数的正式名字，方法的访问修饰符和方法的执行</p>

<h2 id="获取方法的类型信息">获取方法的类型信息</h2>

<p>Method.getReturnType 获取返回值的类型<br />
Method.getGenericReturnType 获取携带泛型参数返回值的类型</p>

<p>Method.getParameterTypes 获取参数的类型数组<br />
Method.getGenericParameterTypes</p>

<p>Method.getExceptionTypes 获取异常声明的类型数组<br />
Method.getGenericExceptionTypes</p>

<p>Method.isVarArgs() 判断方法是否是可变参数列表</p>

<h2 id="获取方法的参数的正式名字">获取方法的参数的正式名字</h2>

<p>类编译为.class文件时，参数的名字都会被短名字替换，为了能够用反射获得参数的名字，需要在编译java代码时加上-parameters参数，</p>

<p>Method.getParameters 获取参数Parameter 对象数组</p>

<p>Parameter.getType 获取参数的类型</p>

<p>Parameter.getName 获取参数的名字</p>

<p>Parameter.getModifiers 获取参数的访问修饰符</p>

<p>Parameter.isNamePresent 判断class文件中是否包含参数的正式名字</p>

<h2 id="获取方法的访问修饰符">获取方法的访问修饰符</h2>

<p>Method.getModifiers 获取方法的访问修饰符</p>

<h2 id="用method的反射api来调用方法">用Method的反射API来调用方法</h2>

<p>Method.invoke 调用方法，传给invoke的第一个参数是一个对象，例如method.invoke(a)相当于非反射调用a.method()，如果调用的静态方法，则参数为invoke的第一个参数null；另外，method.invoke(a, 1, “er”, new int[1]{})相当于a.method(1, “er”, new int[1]{})</p>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/member/methodInvocation.html">完整代码示例</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.Locale;
import static java.lang.System.out;
import static java.lang.System.err;

public class Deet&lt;T&gt; {
    private boolean testDeet(Locale l) {
	// getISO3Language() may throw a MissingResourceException
	out.format("Locale = %s, ISO Language Code = %s%n", l.getDisplayName(), l.getISO3Language());
	return true;
    }

    private int testFoo(Locale l) { return 0; }
    private boolean testBar() { return true; }

    public static void main(String... args) {
	if (args.length != 4) {
	    err.format("Usage: java Deet &lt;classname&gt; &lt;langauge&gt; &lt;country&gt; &lt;variant&gt;%n");
	    return;
	}

	try {
	    Class&lt;?&gt; c = Class.forName(args[0]);
	    Object t = c.newInstance();

	    Method[] allMethods = c.getDeclaredMethods();
	    for (Method m : allMethods) {
		String mname = m.getName();
		if (!mname.startsWith("test")
		    || (m.getGenericReturnType() != boolean.class)) {
		    continue;
		}
 		Type[] pType = m.getGenericParameterTypes();
 		if ((pType.length != 1)
		    || Locale.class.isAssignableFrom(pType[0].getClass())) {
 		    continue;
 		}

		out.format("invoking %s()%n", mname);
		try {
		    m.setAccessible(true);
		    Object o = m.invoke(t, new Locale(args[1], args[2], args[3]));
		    out.format("%s() returned %b%n", mname, (Boolean) o);

		// Handle any exceptions thrown by method to be invoked.
		} catch (InvocationTargetException x) {
		    Throwable cause = x.getCause();
		    err.format("invocation of %s failed: %s%n",
			       mname, cause.getMessage());
		}
	    }

        // production code should handle these exceptions more gracefully
	} catch (ClassNotFoundException x) {
	    x.printStackTrace();
	} catch (InstantiationException x) {
	    x.printStackTrace();
	} catch (IllegalAccessException x) {
	    x.printStackTrace();
	}
    }
}

测试实例

$ java Deet Deet ja JP JP
invoking testDeet()
Locale = Japanese (Japan,JP), 
ISO Language Code = jpn
testDeet() returned true
$ java Deet Deet xx XX XX
invoking testDeet()
invocation of testDeet failed: 
Couldn't find 3-letter language code for xx

</code></pre>
</div>

<p>注意可变参数的方法的调用形式稍微有点不同</p>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/member/methodInvocation.html">完整代码示例</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;

public class InvokeMain {
    public static void main(String... args) {
	try {
	    Class&lt;?&gt; c = Class.forName(args[0]);
	    Class[] argTypes = new Class[] { String[].class };
	    Method main = c.getDeclaredMethod("main", argTypes);
  	    String[] mainArgs = Arrays.copyOfRange(args, 1, args.length);
	    System.out.format("invoking %s.main()%n", c.getName());
	    main.invoke(null, (Object)mainArgs);

        // production code should handle these exceptions more gracefully
	} catch (ClassNotFoundException x) {
	    x.printStackTrace();
	} catch (NoSuchMethodException x) {
	    x.printStackTrace();
	} catch (IllegalAccessException x) {
	    x.printStackTrace();
	} catch (InvocationTargetException x) {
	    x.printStackTrace();
	}
    }
}

测试示例

$ java InvokeMain Deet Deet ja JP JP
invoking Deet.main()
invoking testDeet()
Locale = Japanese (Japan,JP), 
ISO Language Code = jpn
testDeet() returned true

</code></pre>
</div>

<p>对于签名是参数数目可变的函数，其实只是一种语法糖，最终编译结果只是把参数列表变成一个数组，所以使用Method.invoke的时候要传一个数组Object给invoke</p>

<p>有一点容易让人产生疑惑的是Method的invoke函数签名有新旧两个版本<br />
invoke(Object obj,Object[] args)<br />
invoke(Object obj,Object… args)<br />
数组签名是1.4版本，而可变参数类型是1.5版本，如果没有新版本，那么给多参数的函数传参数就得构造一个Object数组了，但如果不把一个数组转强制换成Object的话，编译器就会指定数组版本，导致参数个数异常；另外，基本类型数组是一个Object类型，因此不需要强制转换</p>

<p>另外，可以通过Method.setAccessible来禁止对方法访问的权限检查</p>

<p>注意方法中的泛型变量都会被擦除到边界例如：void method(T t) 运行时实际上是 void method(Object t)</p>

<h1 id="构造器constructors的反射api">构造器(Constructors)的反射API</h1>

<p>构造器常用的反射API包括：获取构造器声明中的类型信息，构造器的正式名字，构造器的访问修饰符和使用构造器的创建对象</p>

<h2 id="获取构造器声明中的类型信息">获取构造器声明中的类型信息</h2>

<p>Constructor.getParameterTypes 获取参数的类型数组<br />
Constructor.getGenericParameterTypes</p>

<p>Constructor.getExceptionTypes 获取异常声明的类型数组<br />
Constructor.getGenericExceptionTypes</p>

<p>Constructor.isVarArgs() 判断方法是否是可变参数列表</p>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/member/ctorLocation.html">完整代码示例</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>import java.lang.reflect.Constructor;
import java.lang.reflect.Type;
import static java.lang.System.out;

public class ConstructorSift {
    public static void main(String... args) {
	try {
	    Class&lt;?&gt; cArg = Class.forName(args[1]);

	    Class&lt;?&gt; c = Class.forName(args[0]);
	    Constructor[] allConstructors = c.getDeclaredConstructors();
	    for (Constructor ctor : allConstructors) {
		Class&lt;?&gt;[] pType  = ctor.getParameterTypes();
		for (int i = 0; i &lt; pType.length; i++) {
		    if (pType[i].equals(cArg)) {
			out.format("%s%n", ctor.toGenericString());

			Type[] gpType = ctor.getGenericParameterTypes();
			for (int j = 0; j &lt; gpType.length; j++) {
			    char ch = (pType[j].equals(cArg) ? '*' : ' ');
			    out.format("%7c%s[%d]: %s%n", ch,
				       "GenericParameterType", j, gpType[j]);
			}
			break;
		    }
		}
	    }

        // production code should handle this exception more gracefully
	} catch (ClassNotFoundException x) {
	    x.printStackTrace();
	}
    }
}

测试示例输出

$ java ConstructorSift java.util.Formatter java.util.Locale
public
java.util.Formatter(java.io.OutputStream,java.lang.String,java.util.Locale)
throws java.io.UnsupportedEncodingException
       GenericParameterType[0]: class java.io.OutputStream
       GenericParameterType[1]: class java.lang.String
      *GenericParameterType[2]: class java.util.Locale
public java.util.Formatter(java.lang.String,java.lang.String,java.util.Locale)
throws java.io.FileNotFoundException,java.io.UnsupportedEncodingException
       GenericParameterType[0]: class java.lang.String
       GenericParameterType[1]: class java.lang.String
      *GenericParameterType[2]: class java.util.Locale
public java.util.Formatter(java.lang.Appendable,java.util.Locale)
       GenericParameterType[0]: interface java.lang.Appendable
      *GenericParameterType[1]: class java.util.Locale
public java.util.Formatter(java.util.Locale)
      *GenericParameterType[0]: class java.util.Locale
public java.util.Formatter(java.io.File,java.lang.String,java.util.Locale)
throws java.io.FileNotFoundException,java.io.UnsupportedEncodingException
       GenericParameterType[0]: class java.io.File
       GenericParameterType[1]: class java.lang.String
      *GenericParameterType[2]: class java.util.Locale

$ java ConstructorSift java.lang.String "[C"
java.lang.String(int,int,char[])
       GenericParameterType[0]: int
       GenericParameterType[1]: int
      *GenericParameterType[2]: class [C
public java.lang.String(char[],int,int)
      *GenericParameterType[0]: class [C
       GenericParameterType[1]: int
       GenericParameterType[2]: int
public java.lang.String(char[])
      *GenericParameterType[0]: class [C
      
$ java ConstructorSift java.lang.ProcessBuilder "[Ljava.lang.String;"
public java.lang.ProcessBuilder(java.lang.String[])
      *GenericParameterType[0]: class [Ljava.lang.String;


</code></pre>
</div>

<h2 id="获取构造器的访问修饰符">获取构造器的访问修饰符</h2>

<p>Constructor.getModifiers</p>

<h2 id="创建对象">创建对象</h2>

<p>Constructor.newInstance 创建一个对象</p>

<p>Class.newInstance和Constructor.newInstance反射API都能创建一个对象，但前者只能调用不带参数的构造器，且要满足访问修饰符的约束；通过修改访问权限可以使用Constructor.newInstance访问private的构造函数</p>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/member/ctorInstance.html">完整代码示例</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import static java.lang.System.out;

class EmailAliases {
    private Set&lt;String&gt; aliases;
    private EmailAliases(HashMap&lt;String, String&gt; h) {
	aliases = h.keySet();
    }

    public void printKeys() {
	out.format("Mail keys:%n");
	for (String k : aliases)
	    out.format("  %s%n", k);
    }
}

public class RestoreAliases {

    private static Map&lt;String, String&gt; defaultAliases = new HashMap&lt;String, String&gt;();
    static {
	defaultAliases.put("Duke", "duke@i-love-java");
	defaultAliases.put("Fang", "fang@evil-jealous-twin");
    }

    public static void main(String... args) {
	try {
	    Constructor ctor = EmailAliases.class.getDeclaredConstructor(HashMap.class);
	    ctor.setAccessible(true);
	    EmailAliases email = (EmailAliases)ctor.newInstance(defaultAliases);
	    email.printKeys();

        // production code should handle these exceptions more gracefully
	} catch (InstantiationException x) {
	    x.printStackTrace();
	} catch (IllegalAccessException x) {
	    x.printStackTrace();
	} catch (InvocationTargetException x) {
	    x.printStackTrace();
	} catch (NoSuchMethodException x) {
	    x.printStackTrace();
	}
    }
}

测试示例

$ java RestoreAliases
Mail keys:
  Duke
  Fang
  
</code></pre>
</div>

<h1 id="数组array反射api">数组(Array)反射API</h1>

<p>常用的数组反射API包括：获取数组的类型，数组元素的类型，创建数组，获取和设置数组元素</p>

<h2 id="获取数组和数组元素的类型">获取数组和数组元素的类型</h2>

<p>Class.isArray 判断一个对象是否为数组<br />
Class.getComponentType 获取数组的元素的类型</p>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/special/arrayComponents.html">完整代码示例</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>import java.lang.reflect.Field;
import java.lang.reflect.Type;
import static java.lang.System.out;

public class ArrayFind {
    public static void main(String... args) {
	boolean found = false;
 	try {
	    Class&lt;?&gt; cls = Class.forName(args[0]);
	    Field[] flds = cls.getDeclaredFields();
	    for (Field f : flds) {
 		Class&lt;?&gt; c = f.getType();
		if (c.isArray()) {
		    found = true;
		    out.format("%s%n"
                               + "           Field: %s%n"
			       + "            Type: %s%n"
			       + "  Component Type: %s%n",
			       f, f.getName(), c, c.getComponentType());
		}
	    }
	    if (!found) {
		out.format("No array fields%n");
	    }

        // production code should handle this exception more gracefully
 	} catch (ClassNotFoundException x) {
	    x.printStackTrace();
	}
    }
}

测试示例

$ java ArrayFind java.lang.Throwable
private java.lang.StackTraceElement[] java.lang.Throwable.stackTrace
           Field: stackTrace
            Type: class [Ljava.lang.StackTraceElement;
  Component Type: class java.lang.StackTraceElement
  
</code></pre>
</div>

<h2 id="创建数组">创建数组</h2>

<p>Array.newInstance 创建多维数组</p>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/special/arrayInstance.html">完整代码示例</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.Arrays;
import static java.lang.System.out;

public class ArrayCreator {
    private static String s = "java.math.BigInteger bi[] = { 123, 234, 345 }";
    private static Pattern p = Pattern.compile("^\\s*(\\S+)\\s*\\w+\\[\\].*\\{\\s*([^}]+)\\s*\\}");

    public static void main(String... args) {
        Matcher m = p.matcher(s);

        if (m.find()) {
            String cName = m.group(1);
            String[] cVals = m.group(2).split("[\\s,]+");
            int n = cVals.length;

            try {
                Class&lt;?&gt; c = Class.forName(cName);
                Object o = Array.newInstance(c, n);
                for (int i = 0; i &lt; n; i++) {
                    String v = cVals[i];
                    Constructor ctor = c.getConstructor(String.class);
                    Object val = ctor.newInstance(v);
                    Array.set(o, i, val);
                }

                Object[] oo = (Object[])o;
                out.format("%s[] = %s%n", cName, Arrays.toString(oo));

            // production code should handle these exceptions more gracefully
            } catch (ClassNotFoundException x) {
                x.printStackTrace();
            } catch (NoSuchMethodException x) {
                x.printStackTrace();
            } catch (IllegalAccessException x) {
                x.printStackTrace();
            } catch (InstantiationException x) {
                x.printStackTrace();
            } catch (InvocationTargetException x) {
                x.printStackTrace();
            }
        }
    }
}
$ java ArrayCreator
java.math.BigInteger [] = [123, 234, 345]

</code></pre>
</div>

<h2 id="获取和设置数组元素">获取和设置数组元素</h2>

<p>Array.set* 设置基本元素<br />
Array.get* 获取基本元素<br />
Array.set 设置引用元素<br />
Array.get 获取引用元素</p>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/special/arraySetGet.html">完整代码示例</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>import java.lang.reflect.Array;
import static java.lang.System.out;

public class CreateMatrix {
    public static void main(String... args) {
        Object matrix = Array.newInstance(int.class, 2, 2);
        Object row0 = Array.get(matrix, 0);
        Object row1 = Array.get(matrix, 1);

        Array.setInt(row0, 0, 1);
        Array.setInt(row0, 1, 2);
        Array.setInt(row1, 0, 3);
        Array.setInt(row1, 1, 4);

        for (int i = 0; i &lt; 2; i++)
            for (int j = 0; j &lt; 2; j++)
                out.format("matrix[%d][%d] = %d%n", i, j, ((int[][])matrix)[i][j]);
    }
}

$ java CreateMatrix
matrix[0][0] = 1
matrix[0][1] = 2
matrix[1][0] = 3
matrix[1][1] = 4

</code></pre>
</div>

<h1 id="枚举enum反射api">枚举(Enum)反射API</h1>

<p>常用枚举反射API包括</p>

<p>Class.isEnum 判断类型是否为枚举<br />
Class.getEnumConstants 获取一个枚举类型的所有枚举值<br />
Field.isEnumConstant 判断一个域是否为枚举常量</p>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/special/enumMembers.html">完整代码示例</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>import java.util.Arrays;
import static java.lang.System.out;

enum Eon { HADEAN, ARCHAEAN, PROTEROZOIC, PHANEROZOIC }

public class EnumConstants {
    public static void main(String... args) {
	try {
	    Class&lt;?&gt; c = (args.length == 0 ? Eon.class : Class.forName(args[0]));
	    out.format("Enum name:  %s%nEnum constants:  %s%n",
		       c.getName(), Arrays.asList(c.getEnumConstants()));
	    if (c == Eon.class)
		out.format("  Eon.values():  %s%n",
			   Arrays.asList(Eon.values()));

        // production code should handle this exception more gracefully
	} catch (ClassNotFoundException x) {
	    x.printStackTrace();
	}
    }
}

测试示例

$ java EnumConstants java.lang.annotation.RetentionPolicy
Enum name:  java.lang.annotation.RetentionPolicy
Enum constants:  [SOURCE, CLASS, RUNTIME]
$ java EnumConstants java.util.concurrent.TimeUnit
Enum name:  java.util.concurrent.TimeUnit
Enum constants:  [NANOSECONDS, MICROSECONDS, 
                  MILLISECONDS, SECONDS, 
                  MINUTES, HOURS, DAYS]

</code></pre>
</div>

<h1 id="参考文献">参考文献</h1>

<p><a href="http://docs.oracle.com/javase/tutorial/reflect/index.html">The Reflection API</a></p>

            </article>
        </div>
      </div>
      <div class="panel docs-content">
        <article class="post-content">
          <div class="wrapper">
            


  <div class="ds-thread" data-thread-key="/2017/05/12/java%E5%8F%8D%E5%B0%84api%E7%AE%80%E4%BB%8B/" data-title="Java反射API简介" data-url="/2017/05/12/java%E5%8F%8D%E5%B0%84api%E7%AE%80%E4%BB%8B/"></div>

<script type="text/javascript">
var duoshuoQuery = {short_name:"junxigu"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
</script>


 
          </div>
        </article>
      </div>
    </div>
  </div>
</div>

    
    <footer class="footer" role="contentinfo">
	<div class="container">
		<p class="copyright">Copyright &copy; 2014-2017 <a href=""><code>Jun Xi Gu</code></a>.</p>
		<p>Customizied from <a href="https://github.com/luoyan35714/LessOrMore">LessOrMore</a></p></p>
		<p>Powered by <a href="http://jekyllrb.com">Jekyll</a>, theme from <a href="http://lesscss.cn/">Less</a></p>
	</div>
</footer>

<script src="/styles/js/jquery.min.js"></script>
<script src="/styles/js/bootstrap.min.js"></script>
<script src="/styles/js/holder.min.js"></script>
<script src="/styles/js/application.js"></script>
<script src="/styles/js/lessismore.js"></script>

  </body>
</html>
